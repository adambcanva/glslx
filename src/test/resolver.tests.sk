namespace GLSLX.Tests {
  def testResolver {

# Test invalid variable types
test("
void main() {
  void v;
}
", "
<stdin>:2:3: error: Cannot create a variable of type \"void\"
  void v;
  ~~~~
")

# Test implicit primitive conversions
test("
void main() {
  int i_i = 0;
  int i_f = 0.0;
  int i_b = false;

  float f_i = 0;
  float f_f = 0.0;
  float f_b = false;

  bool b_i = 0;
  bool b_f = 0.0;
  bool b_b = false;
}
", "
<stdin>:3:13: error: Cannot convert from type \"float\" to type \"int\"
  int i_f = 0.0;
            ~~~
<stdin>:4:13: error: Cannot convert from type \"bool\" to type \"int\"
  int i_b = false;
            ~~~~~
<stdin>:6:15: error: Cannot convert from type \"int\" to type \"float\"
  float f_i = 0;
              ^
<stdin>:8:15: error: Cannot convert from type \"bool\" to type \"float\"
  float f_b = false;
              ~~~~~
<stdin>:10:14: error: Cannot convert from type \"int\" to type \"bool\"
  bool b_i = 0;
             ^
<stdin>:11:14: error: Cannot convert from type \"float\" to type \"bool\"
  bool b_f = 0.0;
             ~~~
")

# Test explicit primitive conversions
test("
void main() {
  int i_i = int(0);
  int i_f = int(0.0);
  int i_b = int(false);

  float f_i = float(0);
  float f_f = float(0.0);
  float f_b = float(false);

  bool b_i = bool(0);
  bool b_f = bool(0.0);
  bool b_b = bool(false);
}
", "
void main() {
  int i_i = int(0);
  int i_f = int(0.0);
  int i_b = int(false);
  float f_i = float(0);
  float f_f = float(0.0);
  float f_b = float(false);
  bool b_i = bool(0);
  bool b_f = bool(0.0);
  bool b_b = bool(false);
}
")

# Test vector constructors
test("
void main() {
  float v1 = 0.0;
  vec2 v2 = vec2(1.0, 2.0);
  vec3 v3 = vec3(1.0, 2.0, 3.0);
  vec4 v4 = vec4(1.0, 2.0, 3.0, 4.0);

  vec2 v2_1 = vec2(v1);
  vec2 v2_2 = vec2(v2);
  vec2 v2_3 = vec2(v3);
  vec2 v2_4 = vec2(v4);
  vec2 v2_5 = vec2(v1, v4);
  vec2 v2_5_error = vec2(v4, v1);

  vec3 v3_1 = vec3(v1);
  vec3 v3_2 = vec3(v2);
  vec3 v3_3 = vec3(v3);
  vec3 v3_4 = vec3(v4);
  vec3 v3_12 = vec3(v1, v2);
  vec3 v3_21 = vec3(v2, v1);
  vec3 v3_5 = vec3(v1, v4);
  vec3 v3_5_error = vec3(v4, v1);

  vec4 v4_1 = vec4(v1);
  vec4 v4_2 = vec4(v2);
  vec4 v4_3 = vec4(v3);
  vec4 v4_4 = vec4(v4);
  vec4 v4_13 = vec4(v1, v3);
  vec4 v4_31 = vec4(v3, v1);
  vec4 v4_22 = vec4(v2, v2);
  vec4 v4_5 = vec4(v1, v4);
  vec4 v4_5_error = vec4(v4, v1);
}
", "
<stdin>:12:30: error: The constructor for type \"vec2\" only takes 2 arguments and this argument would bring the total to 5
  vec2 v2_5_error = vec2(v4, v1);
                             ~~
<stdin>:15:19: error: Cannot construct type \"vec3\" with 2 arguments
  vec3 v3_2 = vec3(v2);
                  ~~~~
<stdin>:21:30: error: The constructor for type \"vec3\" only takes 3 arguments and this argument would bring the total to 5
  vec3 v3_5_error = vec3(v4, v1);
                             ~~
<stdin>:24:19: error: Cannot construct type \"vec4\" with 2 arguments
  vec4 v4_2 = vec4(v2);
                  ~~~~
<stdin>:25:19: error: Cannot construct type \"vec4\" with 3 arguments
  vec4 v4_3 = vec4(v3);
                  ~~~~
<stdin>:31:30: error: The constructor for type \"vec4\" only takes 4 arguments and this argument would bring the total to 5
  vec4 v4_5_error = vec4(v4, v1);
                             ~~
")

# Test vector constructors with matrices
test("
void main() {
  vec2 v22 = vec2(mat2(0.0));
  vec2 v23 = vec2(mat3(0.0));
  vec2 v24 = vec2(mat4(0.0));

  vec3 v32 = vec3(mat2(0.0));
  vec3 v33 = vec3(mat3(0.0));
  vec3 v34 = vec3(mat4(0.0));

  vec4 v42 = vec4(mat2(0.0));
  vec4 v43 = vec4(mat3(0.0));
  vec4 v44 = vec4(mat4(0.0));
}
", "
void main() {
  vec2 v22 = vec2(mat2(0.0));
  vec2 v23 = vec2(mat3(0.0));
  vec2 v24 = vec2(mat4(0.0));
  vec3 v32 = vec3(mat2(0.0));
  vec3 v33 = vec3(mat3(0.0));
  vec3 v34 = vec3(mat4(0.0));
  vec4 v42 = vec4(mat2(0.0));
  vec4 v43 = vec4(mat3(0.0));
  vec4 v44 = vec4(mat4(0.0));
}
")

# Test matrix constructors
test("
void main() {
  mat2(0.0);
  mat2(0.0, 0.0);
  mat2(0.0, 0.0, 0.0);
  mat2(0.0, 0.0, 0.0, 0.0);

  mat3(0.0);
  mat3(0.0, 0.0);
  mat3(0.0, 0.0, 0.0);
  mat3(0.0, 0.0, 0.0, 0.0);
  mat3(
    0.0, 0.0, 0.0,
    0.0, 0.0, 0.0,
    0.0, 0.0, 0.0);

  mat4(0.0);
  mat4(0.0, 0.0);
  mat4(0.0, 0.0, 0.0);
  mat4(0.0, 0.0, 0.0, 0.0);
  mat4(
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0);
}
", "
<stdin>:3:7: error: Cannot construct type \"mat2\" with 2 arguments
  mat2(0.0, 0.0);
      ~~~~~~~~~~
<stdin>:4:7: error: Cannot construct type \"mat2\" with 3 arguments
  mat2(0.0, 0.0, 0.0);
      ~~~~~~~~~~~~~~~
<stdin>:8:7: error: Cannot construct type \"mat3\" with 2 arguments
  mat3(0.0, 0.0);
      ~~~~~~~~~~
<stdin>:9:7: error: Cannot construct type \"mat3\" with 3 arguments
  mat3(0.0, 0.0, 0.0);
      ~~~~~~~~~~~~~~~
<stdin>:10:7: error: Cannot construct type \"mat3\" with 4 arguments
  mat3(0.0, 0.0, 0.0, 0.0);
      ~~~~~~~~~~~~~~~~~~~~
<stdin>:17:7: error: Cannot construct type \"mat4\" with 2 arguments
  mat4(0.0, 0.0);
      ~~~~~~~~~~
<stdin>:18:7: error: Cannot construct type \"mat4\" with 3 arguments
  mat4(0.0, 0.0, 0.0);
      ~~~~~~~~~~~~~~~
<stdin>:19:7: error: Cannot construct type \"mat4\" with 4 arguments
  mat4(0.0, 0.0, 0.0, 0.0);
      ~~~~~~~~~~~~~~~~~~~~
")

# Check special matrix constructor rule
test("
void main() {
  mat3(mat2(1), mat2(1), 1);
  mat3(1, mat2(1), mat2(1));
  mat3(1, mat2(1), vec4(1));
  mat3(mat2(1), vec4(1), 1);
  mat3(vec4(1), mat2(1), 1);

  mat2(mat3(1));
  mat3(mat2(1));

  mat2(mat4(1));
  mat4(mat2(1));

  mat3(mat4(1));
  mat4(mat3(1));
}
", "
<stdin>:2:7: error: If a matrix argument is given to a matrix constructor, it is an error to have any other arguments
  mat3(mat2(1), mat2(1), 1);
      ~~~~~~~~~~~~~~~~~~~~~
<stdin>:3:7: error: If a matrix argument is given to a matrix constructor, it is an error to have any other arguments
  mat3(1, mat2(1), mat2(1));
      ~~~~~~~~~~~~~~~~~~~~~
<stdin>:4:7: error: If a matrix argument is given to a matrix constructor, it is an error to have any other arguments
  mat3(1, mat2(1), vec4(1));
      ~~~~~~~~~~~~~~~~~~~~~
<stdin>:5:7: error: If a matrix argument is given to a matrix constructor, it is an error to have any other arguments
  mat3(mat2(1), vec4(1), 1);
      ~~~~~~~~~~~~~~~~~~~~~
<stdin>:6:7: error: If a matrix argument is given to a matrix constructor, it is an error to have any other arguments
  mat3(vec4(1), mat2(1), 1);
      ~~~~~~~~~~~~~~~~~~~~~
")

# Empty constructors are not allowed
test("
void main() {
  bool();
  int();
  float();
  ivec2();
  ivec3();
  ivec4();
  bvec2();
  bvec3();
  bvec4();
  vec2();
  vec3();
  vec4();
  mat2();
  mat3();
  mat4();
}
", "
<stdin>:2:7: error: Cannot construct type \"bool\" with 0 arguments
  bool();
      ~~
<stdin>:3:6: error: Cannot construct type \"int\" with 0 arguments
  int();
     ~~
<stdin>:4:8: error: Cannot construct type \"float\" with 0 arguments
  float();
       ~~
<stdin>:5:8: error: Cannot construct type \"ivec2\" with 0 arguments
  ivec2();
       ~~
<stdin>:6:8: error: Cannot construct type \"ivec3\" with 0 arguments
  ivec3();
       ~~
<stdin>:7:8: error: Cannot construct type \"ivec4\" with 0 arguments
  ivec4();
       ~~
<stdin>:8:8: error: Cannot construct type \"bvec2\" with 0 arguments
  bvec2();
       ~~
<stdin>:9:8: error: Cannot construct type \"bvec3\" with 0 arguments
  bvec3();
       ~~
<stdin>:10:8: error: Cannot construct type \"bvec4\" with 0 arguments
  bvec4();
       ~~
<stdin>:11:7: error: Cannot construct type \"vec2\" with 0 arguments
  vec2();
      ~~
<stdin>:12:7: error: Cannot construct type \"vec3\" with 0 arguments
  vec3();
      ~~
<stdin>:13:7: error: Cannot construct type \"vec4\" with 0 arguments
  vec4();
      ~~
<stdin>:14:7: error: Cannot construct type \"mat2\" with 0 arguments
  mat2();
      ~~
<stdin>:15:7: error: Cannot construct type \"mat3\" with 0 arguments
  mat3();
      ~~
<stdin>:16:7: error: Cannot construct type \"mat4\" with 0 arguments
  mat4();
      ~~
")

# Test matrix-matrix multiplications
test("
void main() {
  int m22 = mat2(0.0) * mat2(0.0);
  int m23 = mat2(0.0) * mat3(0.0);
  int m24 = mat2(0.0) * mat4(0.0);

  int m32 = mat3(0.0) * mat2(0.0);
  int m33 = mat3(0.0) * mat3(0.0);
  int m34 = mat3(0.0) * mat4(0.0);

  int m42 = mat4(0.0) * mat2(0.0);
  int m43 = mat4(0.0) * mat3(0.0);
  int m44 = mat4(0.0) * mat4(0.0);
}
", "
<stdin>:2:13: error: Cannot convert from type \"mat2\" to type \"int\"
  int m22 = mat2(0.0) * mat2(0.0);
            ~~~~~~~~~~~~~~~~~~~~~
<stdin>:3:23: error: No binary operator \"*\" for type \"mat2\" and type \"mat3\"
  int m23 = mat2(0.0) * mat3(0.0);
                      ^
<stdin>:4:23: error: No binary operator \"*\" for type \"mat2\" and type \"mat4\"
  int m24 = mat2(0.0) * mat4(0.0);
                      ^
<stdin>:6:23: error: No binary operator \"*\" for type \"mat3\" and type \"mat2\"
  int m32 = mat3(0.0) * mat2(0.0);
                      ^
<stdin>:7:13: error: Cannot convert from type \"mat3\" to type \"int\"
  int m33 = mat3(0.0) * mat3(0.0);
            ~~~~~~~~~~~~~~~~~~~~~
<stdin>:8:23: error: No binary operator \"*\" for type \"mat3\" and type \"mat4\"
  int m34 = mat3(0.0) * mat4(0.0);
                      ^
<stdin>:10:23: error: No binary operator \"*\" for type \"mat4\" and type \"mat2\"
  int m42 = mat4(0.0) * mat2(0.0);
                      ^
<stdin>:11:23: error: No binary operator \"*\" for type \"mat4\" and type \"mat3\"
  int m43 = mat4(0.0) * mat3(0.0);
                      ^
<stdin>:12:13: error: Cannot convert from type \"mat4\" to type \"int\"
  int m44 = mat4(0.0) * mat4(0.0);
            ~~~~~~~~~~~~~~~~~~~~~
")

# Test vector-matrix and matrix-vector multiplications
test("
void main() {
  int vm22 = vec2(0.0) * mat2(0.0);
  int vm23 = vec2(0.0) * mat3(0.0);
  int vm24 = vec2(0.0) * mat4(0.0);

  int vm32 = vec3(0.0) * mat2(0.0);
  int vm33 = vec3(0.0) * mat3(0.0);
  int vm34 = vec3(0.0) * mat4(0.0);

  int vm42 = vec4(0.0) * mat2(0.0);
  int vm43 = vec4(0.0) * mat3(0.0);
  int vm44 = vec4(0.0) * mat4(0.0);

  int mv22 = mat2(0.0) * vec2(0.0);
  int mv23 = mat2(0.0) * vec3(0.0);
  int mv24 = mat2(0.0) * vec4(0.0);

  int mv32 = mat3(0.0) * vec2(0.0);
  int mv33 = mat3(0.0) * vec3(0.0);
  int mv34 = mat3(0.0) * vec4(0.0);

  int mv42 = mat4(0.0) * vec2(0.0);
  int mv43 = mat4(0.0) * vec3(0.0);
  int mv44 = mat4(0.0) * vec4(0.0);
}
", "
<stdin>:2:14: error: Cannot convert from type \"vec2\" to type \"int\"
  int vm22 = vec2(0.0) * mat2(0.0);
             ~~~~~~~~~~~~~~~~~~~~~
<stdin>:3:24: error: No binary operator \"*\" for type \"vec2\" and type \"mat3\"
  int vm23 = vec2(0.0) * mat3(0.0);
                       ^
<stdin>:4:24: error: No binary operator \"*\" for type \"vec2\" and type \"mat4\"
  int vm24 = vec2(0.0) * mat4(0.0);
                       ^
<stdin>:6:24: error: No binary operator \"*\" for type \"vec3\" and type \"mat2\"
  int vm32 = vec3(0.0) * mat2(0.0);
                       ^
<stdin>:7:14: error: Cannot convert from type \"vec3\" to type \"int\"
  int vm33 = vec3(0.0) * mat3(0.0);
             ~~~~~~~~~~~~~~~~~~~~~
<stdin>:8:24: error: No binary operator \"*\" for type \"vec3\" and type \"mat4\"
  int vm34 = vec3(0.0) * mat4(0.0);
                       ^
<stdin>:10:24: error: No binary operator \"*\" for type \"vec4\" and type \"mat2\"
  int vm42 = vec4(0.0) * mat2(0.0);
                       ^
<stdin>:11:24: error: No binary operator \"*\" for type \"vec4\" and type \"mat3\"
  int vm43 = vec4(0.0) * mat3(0.0);
                       ^
<stdin>:12:14: error: Cannot convert from type \"vec4\" to type \"int\"
  int vm44 = vec4(0.0) * mat4(0.0);
             ~~~~~~~~~~~~~~~~~~~~~
<stdin>:14:14: error: Cannot convert from type \"vec2\" to type \"int\"
  int mv22 = mat2(0.0) * vec2(0.0);
             ~~~~~~~~~~~~~~~~~~~~~
<stdin>:15:24: error: No binary operator \"*\" for type \"mat2\" and type \"vec3\"
  int mv23 = mat2(0.0) * vec3(0.0);
                       ^
<stdin>:16:24: error: No binary operator \"*\" for type \"mat2\" and type \"vec4\"
  int mv24 = mat2(0.0) * vec4(0.0);
                       ^
<stdin>:18:24: error: No binary operator \"*\" for type \"mat3\" and type \"vec2\"
  int mv32 = mat3(0.0) * vec2(0.0);
                       ^
<stdin>:19:14: error: Cannot convert from type \"vec3\" to type \"int\"
  int mv33 = mat3(0.0) * vec3(0.0);
             ~~~~~~~~~~~~~~~~~~~~~
<stdin>:20:24: error: No binary operator \"*\" for type \"mat3\" and type \"vec4\"
  int mv34 = mat3(0.0) * vec4(0.0);
                       ^
<stdin>:22:24: error: No binary operator \"*\" for type \"mat4\" and type \"vec2\"
  int mv42 = mat4(0.0) * vec2(0.0);
                       ^
<stdin>:23:24: error: No binary operator \"*\" for type \"mat4\" and type \"vec3\"
  int mv43 = mat4(0.0) * vec3(0.0);
                       ^
<stdin>:24:14: error: Cannot convert from type \"vec4\" to type \"int\"
  int mv44 = mat4(0.0) * vec4(0.0);
             ~~~~~~~~~~~~~~~~~~~~~
")

# Must assign to a location with storage
test("
uniform int a;
uniform vec2 b;

void main(int x, vec2 y) {
  // Bad
  0 = 0;
  vec2(0.0) = vec2(0.0);
  vec2(0.0).y = 0.0;
  vec2(0.0)[0] = 0.0;

  // Good
  x = 0;
  y = vec2(0.0);
  y.y = 0.0;
  y[0] = 0.0;

  // Bad
  0 += 0;
  vec2(0.0) += vec2(0.0);
  vec2(0.0).y += 0.0;
  vec2(0.0)[0] += 0.0;

  // Good
  x += 0;
  y += vec2(0.0);
  y.y += 0.0;
  y[0] += 0.0;

  // Bad
  vec2(0.0)[0]++;
  --vec2(0.0)[0];

  // Good
  y[0]++;
  --y[0];

  // Bad
  a = 0;
  a++;
  b.x = 0.0;
  b.x += 0.0;
}
", "
<stdin>:6:3: error: Cannot store to this location
  0 = 0;
  ^
<stdin>:7:3: error: Cannot store to this location
  vec2(0.0) = vec2(0.0);
  ~~~~~~~~~
<stdin>:8:3: error: Cannot store to this location
  vec2(0.0).y = 0.0;
  ~~~~~~~~~~~
<stdin>:9:3: error: Cannot store to this location
  vec2(0.0)[0] = 0.0;
  ~~~~~~~~~~~~
<stdin>:18:3: error: Cannot store to this location
  0 += 0;
  ^
<stdin>:19:3: error: Cannot store to this location
  vec2(0.0) += vec2(0.0);
  ~~~~~~~~~
<stdin>:20:3: error: Cannot store to this location
  vec2(0.0).y += 0.0;
  ~~~~~~~~~~~
<stdin>:21:3: error: Cannot store to this location
  vec2(0.0)[0] += 0.0;
  ~~~~~~~~~~~~
<stdin>:30:3: error: Cannot store to this location
  vec2(0.0)[0]++;
  ~~~~~~~~~~~~
<stdin>:31:5: error: Cannot store to this location
  --vec2(0.0)[0];
    ~~~~~~~~~~~~
<stdin>:38:3: error: Cannot store to this location
  a = 0;
  ^
<stdin>:39:3: error: Cannot store to this location
  a++;
  ^
<stdin>:40:3: error: Cannot store to this location
  b.x = 0.0;
  ~~~
<stdin>:41:3: error: Cannot store to this location
  b.x += 0.0;
  ~~~
")

# Cannot assign to a constant
test("
void main(const int a, const int b[2]) {
  const vec2 c = vec2(0.0);

  a = 0;
  b[0] = 0;
  c = vec2(0.0);
  c.x = 0.0;
  c[0] = 0.0;

  a += 0;
  b[0] += 0;
  c += vec2(0.0);
  c.x += 0.0;
  c[0] += 0.0;
}
", "
<stdin>:4:3: error: Cannot store to this location
  a = 0;
  ^
<stdin>:5:3: error: Cannot store to this location
  b[0] = 0;
  ~~~~
<stdin>:6:3: error: Cannot store to this location
  c = vec2(0.0);
  ^
<stdin>:7:3: error: Cannot store to this location
  c.x = 0.0;
  ~~~
<stdin>:8:3: error: Cannot store to this location
  c[0] = 0.0;
  ~~~~
<stdin>:10:3: error: Cannot store to this location
  a += 0;
  ^
<stdin>:11:3: error: Cannot store to this location
  b[0] += 0;
  ~~~~
<stdin>:12:3: error: Cannot store to this location
  c += vec2(0.0);
  ^
<stdin>:13:3: error: Cannot store to this location
  c.x += 0.0;
  ~~~
<stdin>:14:3: error: Cannot store to this location
  c[0] += 0.0;
  ~~~~
")

# Constants must be initialized
test("
void main(const int a) {
  const int b;
  const int c = 0;
}
", "
<stdin>:2:13: error: Constants must be initialized
  const int b;
            ^
")

# Bool conversions for control flow
test("
void main() {
  if (0) {} else if (0) {}
  while (0) {}
  do {} while (0);
  for (; 0;) {}
  0 ? 0 : 0;
}
", "
<stdin>:2:7: error: Cannot convert from type \"int\" to type \"bool\"
  if (0) {} else if (0) {}
      ^
<stdin>:2:22: error: Cannot convert from type \"int\" to type \"bool\"
  if (0) {} else if (0) {}
                     ^
<stdin>:3:10: error: Cannot convert from type \"int\" to type \"bool\"
  while (0) {}
         ^
<stdin>:4:16: error: Cannot convert from type \"int\" to type \"bool\"
  do {} while (0);
               ^
<stdin>:5:10: error: Cannot convert from type \"int\" to type \"bool\"
  for (; 0;) {}
         ^
<stdin>:6:3: error: Cannot convert from type \"int\" to type \"bool\"
  0 ? 0 : 0;
  ^
")

# Conditional expression type merging
test("
void main(bool b) {
  b ? 0 : 0;
  b ? 0 : 0.0;
  b ? 0 : false;
}
", "
<stdin>:3:7: error: Cannot merge type \"int\" and type \"float\"
  b ? 0 : 0.0;
      ~~~~~~~
<stdin>:4:7: error: Cannot merge type \"int\" and type \"bool\"
  b ? 0 : false;
      ~~~~~~~~~
")

# Conditional expressions involving arrays are not allowed
test("
struct S1 {
  int x[2];
};

struct S2 {
  sampler2D x;
};

void main(int a[2], bool b, S1 s1, S2 s2) {
  b ? b : b;
  b ? a : a;
  b ? s1 : s1;
  b ? s2 : s2;
}
", "
<stdin>:11:7: error: Cannot use a conditional expression with array type \"int[2]\"
  b ? a : a;
      ~~~~~
<stdin>:12:7: error: Cannot use a conditional expression with type \"S1\" because it contains an array
  b ? s1 : s1;
      ~~~~~~~
")

# Assignments involving arrays are not allowed
test("
struct S1 {
  int x[2];
};

struct S2 {
  sampler2D x;
};

void main(int a[2], bool b, S1 s1, S2 s2) {
  a = a;
  b = b;
  s1 = s1;
  s2 = s2;
  S1 t1 = s1;
  S2 t2 = s2;
}
", "
<stdin>:10:5: error: Cannot assign to array type \"int[2]\"
  a = a;
    ^
<stdin>:12:6: error: Cannot assign to type \"S1\" because it contains an array
  s1 = s1;
     ^
<stdin>:14:9: error: Cannot assign to type \"S1\" because it contains an array
  S1 t1 = s1;
        ^
")

# Vector-matrix and matrix-vector addition
test("
void main() {
  vec2(0.0) + vec2(0.0); vec2(0.0) + vec2(0.0);
  vec2(0.0) + vec3(0.0); vec3(0.0) + vec2(0.0);
  vec2(0.0) + vec4(0.0); vec4(0.0) + vec2(0.0);
  vec2(0.0) + mat2(0.0); mat2(0.0) + vec2(0.0);
  vec2(0.0) + mat3(0.0); mat3(0.0) + vec2(0.0);
  vec2(0.0) + mat4(0.0); mat4(0.0) + vec2(0.0);

  vec3(0.0) + vec2(0.0); vec2(0.0) + vec3(0.0);
  vec3(0.0) + vec3(0.0); vec3(0.0) + vec3(0.0);
  vec3(0.0) + vec4(0.0); vec4(0.0) + vec3(0.0);
  vec3(0.0) + mat2(0.0); mat2(0.0) + vec3(0.0);
  vec3(0.0) + mat3(0.0); mat3(0.0) + vec3(0.0);
  vec3(0.0) + mat4(0.0); mat4(0.0) + vec3(0.0);

  vec4(0.0) + vec2(0.0); vec2(0.0) + vec4(0.0);
  vec4(0.0) + vec3(0.0); vec3(0.0) + vec4(0.0);
  vec4(0.0) + vec4(0.0); vec4(0.0) + vec4(0.0);
  vec4(0.0) + mat2(0.0); mat2(0.0) + vec4(0.0);
  vec4(0.0) + mat3(0.0); mat3(0.0) + vec4(0.0);
  vec4(0.0) + mat4(0.0); mat4(0.0) + vec4(0.0);
}
", "
<stdin>:3:13: error: No binary operator \"+\" for type \"vec2\" and type \"vec3\"
  vec2(0.0) + vec3(0.0); vec3(0.0) + vec2(0.0);
            ^
<stdin>:3:36: error: No binary operator \"+\" for type \"vec3\" and type \"vec2\"
  vec2(0.0) + vec3(0.0); vec3(0.0) + vec2(0.0);
                                   ^
<stdin>:4:13: error: No binary operator \"+\" for type \"vec2\" and type \"vec4\"
  vec2(0.0) + vec4(0.0); vec4(0.0) + vec2(0.0);
            ^
<stdin>:4:36: error: No binary operator \"+\" for type \"vec4\" and type \"vec2\"
  vec2(0.0) + vec4(0.0); vec4(0.0) + vec2(0.0);
                                   ^
<stdin>:5:13: error: No binary operator \"+\" for type \"vec2\" and type \"mat2\"
  vec2(0.0) + mat2(0.0); mat2(0.0) + vec2(0.0);
            ^
<stdin>:5:36: error: No binary operator \"+\" for type \"mat2\" and type \"vec2\"
  vec2(0.0) + mat2(0.0); mat2(0.0) + vec2(0.0);
                                   ^
<stdin>:6:13: error: No binary operator \"+\" for type \"vec2\" and type \"mat3\"
  vec2(0.0) + mat3(0.0); mat3(0.0) + vec2(0.0);
            ^
<stdin>:6:36: error: No binary operator \"+\" for type \"mat3\" and type \"vec2\"
  vec2(0.0) + mat3(0.0); mat3(0.0) + vec2(0.0);
                                   ^
<stdin>:7:13: error: No binary operator \"+\" for type \"vec2\" and type \"mat4\"
  vec2(0.0) + mat4(0.0); mat4(0.0) + vec2(0.0);
            ^
<stdin>:7:36: error: No binary operator \"+\" for type \"mat4\" and type \"vec2\"
  vec2(0.0) + mat4(0.0); mat4(0.0) + vec2(0.0);
                                   ^
<stdin>:9:13: error: No binary operator \"+\" for type \"vec3\" and type \"vec2\"
  vec3(0.0) + vec2(0.0); vec2(0.0) + vec3(0.0);
            ^
<stdin>:9:36: error: No binary operator \"+\" for type \"vec2\" and type \"vec3\"
  vec3(0.0) + vec2(0.0); vec2(0.0) + vec3(0.0);
                                   ^
<stdin>:11:13: error: No binary operator \"+\" for type \"vec3\" and type \"vec4\"
  vec3(0.0) + vec4(0.0); vec4(0.0) + vec3(0.0);
            ^
<stdin>:11:36: error: No binary operator \"+\" for type \"vec4\" and type \"vec3\"
  vec3(0.0) + vec4(0.0); vec4(0.0) + vec3(0.0);
                                   ^
<stdin>:12:13: error: No binary operator \"+\" for type \"vec3\" and type \"mat2\"
  vec3(0.0) + mat2(0.0); mat2(0.0) + vec3(0.0);
            ^
<stdin>:12:36: error: No binary operator \"+\" for type \"mat2\" and type \"vec3\"
  vec3(0.0) + mat2(0.0); mat2(0.0) + vec3(0.0);
                                   ^
<stdin>:13:13: error: No binary operator \"+\" for type \"vec3\" and type \"mat3\"
  vec3(0.0) + mat3(0.0); mat3(0.0) + vec3(0.0);
            ^
<stdin>:13:36: error: No binary operator \"+\" for type \"mat3\" and type \"vec3\"
  vec3(0.0) + mat3(0.0); mat3(0.0) + vec3(0.0);
                                   ^
<stdin>:14:13: error: No binary operator \"+\" for type \"vec3\" and type \"mat4\"
  vec3(0.0) + mat4(0.0); mat4(0.0) + vec3(0.0);
            ^
<stdin>:14:36: error: No binary operator \"+\" for type \"mat4\" and type \"vec3\"
  vec3(0.0) + mat4(0.0); mat4(0.0) + vec3(0.0);
                                   ^
<stdin>:16:13: error: No binary operator \"+\" for type \"vec4\" and type \"vec2\"
  vec4(0.0) + vec2(0.0); vec2(0.0) + vec4(0.0);
            ^
<stdin>:16:36: error: No binary operator \"+\" for type \"vec2\" and type \"vec4\"
  vec4(0.0) + vec2(0.0); vec2(0.0) + vec4(0.0);
                                   ^
<stdin>:17:13: error: No binary operator \"+\" for type \"vec4\" and type \"vec3\"
  vec4(0.0) + vec3(0.0); vec3(0.0) + vec4(0.0);
            ^
<stdin>:17:36: error: No binary operator \"+\" for type \"vec3\" and type \"vec4\"
  vec4(0.0) + vec3(0.0); vec3(0.0) + vec4(0.0);
                                   ^
<stdin>:19:13: error: No binary operator \"+\" for type \"vec4\" and type \"mat2\"
  vec4(0.0) + mat2(0.0); mat2(0.0) + vec4(0.0);
            ^
<stdin>:19:36: error: No binary operator \"+\" for type \"mat2\" and type \"vec4\"
  vec4(0.0) + mat2(0.0); mat2(0.0) + vec4(0.0);
                                   ^
<stdin>:20:13: error: No binary operator \"+\" for type \"vec4\" and type \"mat3\"
  vec4(0.0) + mat3(0.0); mat3(0.0) + vec4(0.0);
            ^
<stdin>:20:36: error: No binary operator \"+\" for type \"mat3\" and type \"vec4\"
  vec4(0.0) + mat3(0.0); mat3(0.0) + vec4(0.0);
                                   ^
<stdin>:21:13: error: No binary operator \"+\" for type \"vec4\" and type \"mat4\"
  vec4(0.0) + mat4(0.0); mat4(0.0) + vec4(0.0);
            ^
<stdin>:21:36: error: No binary operator \"+\" for type \"mat4\" and type \"vec4\"
  vec4(0.0) + mat4(0.0); mat4(0.0) + vec4(0.0);
                                   ^
")

# Vector-matrix and matrix-vector subtraction
test("
void main() {
  vec2(0.0) - vec2(0.0); vec2(0.0) - vec2(0.0);
  vec2(0.0) - vec3(0.0); vec3(0.0) - vec2(0.0);
  vec2(0.0) - vec4(0.0); vec4(0.0) - vec2(0.0);
  vec2(0.0) - mat2(0.0); mat2(0.0) - vec2(0.0);
  vec2(0.0) - mat3(0.0); mat3(0.0) - vec2(0.0);
  vec2(0.0) - mat4(0.0); mat4(0.0) - vec2(0.0);

  vec3(0.0) - vec2(0.0); vec2(0.0) - vec3(0.0);
  vec3(0.0) - vec3(0.0); vec3(0.0) - vec3(0.0);
  vec3(0.0) - vec4(0.0); vec4(0.0) - vec3(0.0);
  vec3(0.0) - mat2(0.0); mat2(0.0) - vec3(0.0);
  vec3(0.0) - mat3(0.0); mat3(0.0) - vec3(0.0);
  vec3(0.0) - mat4(0.0); mat4(0.0) - vec3(0.0);

  vec4(0.0) - vec2(0.0); vec2(0.0) - vec4(0.0);
  vec4(0.0) - vec3(0.0); vec3(0.0) - vec4(0.0);
  vec4(0.0) - vec4(0.0); vec4(0.0) - vec4(0.0);
  vec4(0.0) - mat2(0.0); mat2(0.0) - vec4(0.0);
  vec4(0.0) - mat3(0.0); mat3(0.0) - vec4(0.0);
  vec4(0.0) - mat4(0.0); mat4(0.0) - vec4(0.0);
}
", "
<stdin>:3:13: error: No binary operator \"-\" for type \"vec2\" and type \"vec3\"
  vec2(0.0) - vec3(0.0); vec3(0.0) - vec2(0.0);
            ^
<stdin>:3:36: error: No binary operator \"-\" for type \"vec3\" and type \"vec2\"
  vec2(0.0) - vec3(0.0); vec3(0.0) - vec2(0.0);
                                   ^
<stdin>:4:13: error: No binary operator \"-\" for type \"vec2\" and type \"vec4\"
  vec2(0.0) - vec4(0.0); vec4(0.0) - vec2(0.0);
            ^
<stdin>:4:36: error: No binary operator \"-\" for type \"vec4\" and type \"vec2\"
  vec2(0.0) - vec4(0.0); vec4(0.0) - vec2(0.0);
                                   ^
<stdin>:5:13: error: No binary operator \"-\" for type \"vec2\" and type \"mat2\"
  vec2(0.0) - mat2(0.0); mat2(0.0) - vec2(0.0);
            ^
<stdin>:5:36: error: No binary operator \"-\" for type \"mat2\" and type \"vec2\"
  vec2(0.0) - mat2(0.0); mat2(0.0) - vec2(0.0);
                                   ^
<stdin>:6:13: error: No binary operator \"-\" for type \"vec2\" and type \"mat3\"
  vec2(0.0) - mat3(0.0); mat3(0.0) - vec2(0.0);
            ^
<stdin>:6:36: error: No binary operator \"-\" for type \"mat3\" and type \"vec2\"
  vec2(0.0) - mat3(0.0); mat3(0.0) - vec2(0.0);
                                   ^
<stdin>:7:13: error: No binary operator \"-\" for type \"vec2\" and type \"mat4\"
  vec2(0.0) - mat4(0.0); mat4(0.0) - vec2(0.0);
            ^
<stdin>:7:36: error: No binary operator \"-\" for type \"mat4\" and type \"vec2\"
  vec2(0.0) - mat4(0.0); mat4(0.0) - vec2(0.0);
                                   ^
<stdin>:9:13: error: No binary operator \"-\" for type \"vec3\" and type \"vec2\"
  vec3(0.0) - vec2(0.0); vec2(0.0) - vec3(0.0);
            ^
<stdin>:9:36: error: No binary operator \"-\" for type \"vec2\" and type \"vec3\"
  vec3(0.0) - vec2(0.0); vec2(0.0) - vec3(0.0);
                                   ^
<stdin>:11:13: error: No binary operator \"-\" for type \"vec3\" and type \"vec4\"
  vec3(0.0) - vec4(0.0); vec4(0.0) - vec3(0.0);
            ^
<stdin>:11:36: error: No binary operator \"-\" for type \"vec4\" and type \"vec3\"
  vec3(0.0) - vec4(0.0); vec4(0.0) - vec3(0.0);
                                   ^
<stdin>:12:13: error: No binary operator \"-\" for type \"vec3\" and type \"mat2\"
  vec3(0.0) - mat2(0.0); mat2(0.0) - vec3(0.0);
            ^
<stdin>:12:36: error: No binary operator \"-\" for type \"mat2\" and type \"vec3\"
  vec3(0.0) - mat2(0.0); mat2(0.0) - vec3(0.0);
                                   ^
<stdin>:13:13: error: No binary operator \"-\" for type \"vec3\" and type \"mat3\"
  vec3(0.0) - mat3(0.0); mat3(0.0) - vec3(0.0);
            ^
<stdin>:13:36: error: No binary operator \"-\" for type \"mat3\" and type \"vec3\"
  vec3(0.0) - mat3(0.0); mat3(0.0) - vec3(0.0);
                                   ^
<stdin>:14:13: error: No binary operator \"-\" for type \"vec3\" and type \"mat4\"
  vec3(0.0) - mat4(0.0); mat4(0.0) - vec3(0.0);
            ^
<stdin>:14:36: error: No binary operator \"-\" for type \"mat4\" and type \"vec3\"
  vec3(0.0) - mat4(0.0); mat4(0.0) - vec3(0.0);
                                   ^
<stdin>:16:13: error: No binary operator \"-\" for type \"vec4\" and type \"vec2\"
  vec4(0.0) - vec2(0.0); vec2(0.0) - vec4(0.0);
            ^
<stdin>:16:36: error: No binary operator \"-\" for type \"vec2\" and type \"vec4\"
  vec4(0.0) - vec2(0.0); vec2(0.0) - vec4(0.0);
                                   ^
<stdin>:17:13: error: No binary operator \"-\" for type \"vec4\" and type \"vec3\"
  vec4(0.0) - vec3(0.0); vec3(0.0) - vec4(0.0);
            ^
<stdin>:17:36: error: No binary operator \"-\" for type \"vec3\" and type \"vec4\"
  vec4(0.0) - vec3(0.0); vec3(0.0) - vec4(0.0);
                                   ^
<stdin>:19:13: error: No binary operator \"-\" for type \"vec4\" and type \"mat2\"
  vec4(0.0) - mat2(0.0); mat2(0.0) - vec4(0.0);
            ^
<stdin>:19:36: error: No binary operator \"-\" for type \"mat2\" and type \"vec4\"
  vec4(0.0) - mat2(0.0); mat2(0.0) - vec4(0.0);
                                   ^
<stdin>:20:13: error: No binary operator \"-\" for type \"vec4\" and type \"mat3\"
  vec4(0.0) - mat3(0.0); mat3(0.0) - vec4(0.0);
            ^
<stdin>:20:36: error: No binary operator \"-\" for type \"mat3\" and type \"vec4\"
  vec4(0.0) - mat3(0.0); mat3(0.0) - vec4(0.0);
                                   ^
<stdin>:21:13: error: No binary operator \"-\" for type \"vec4\" and type \"mat4\"
  vec4(0.0) - mat4(0.0); mat4(0.0) - vec4(0.0);
            ^
<stdin>:21:36: error: No binary operator \"-\" for type \"mat4\" and type \"vec4\"
  vec4(0.0) - mat4(0.0); mat4(0.0) - vec4(0.0);
                                   ^
")

# Vector-matrix and matrix-vector multiplication
test("
void main() {
  vec2(0.0) * vec2(0.0); vec2(0.0) * vec2(0.0);
  vec2(0.0) * vec3(0.0); vec3(0.0) * vec2(0.0);
  vec2(0.0) * vec4(0.0); vec4(0.0) * vec2(0.0);
  vec2(0.0) * mat2(0.0); mat2(0.0) * vec2(0.0);
  vec2(0.0) * mat3(0.0); mat3(0.0) * vec2(0.0);
  vec2(0.0) * mat4(0.0); mat4(0.0) * vec2(0.0);

  vec3(0.0) * vec2(0.0); vec2(0.0) * vec3(0.0);
  vec3(0.0) * vec3(0.0); vec3(0.0) * vec3(0.0);
  vec3(0.0) * vec4(0.0); vec4(0.0) * vec3(0.0);
  vec3(0.0) * mat2(0.0); mat2(0.0) * vec3(0.0);
  vec3(0.0) * mat3(0.0); mat3(0.0) * vec3(0.0);
  vec3(0.0) * mat4(0.0); mat4(0.0) * vec3(0.0);

  vec4(0.0) * vec2(0.0); vec2(0.0) * vec4(0.0);
  vec4(0.0) * vec3(0.0); vec3(0.0) * vec4(0.0);
  vec4(0.0) * vec4(0.0); vec4(0.0) * vec4(0.0);
  vec4(0.0) * mat2(0.0); mat2(0.0) * vec4(0.0);
  vec4(0.0) * mat3(0.0); mat3(0.0) * vec4(0.0);
  vec4(0.0) * mat4(0.0); mat4(0.0) * vec4(0.0);
}
", "
<stdin>:3:13: error: No binary operator \"*\" for type \"vec2\" and type \"vec3\"
  vec2(0.0) * vec3(0.0); vec3(0.0) * vec2(0.0);
            ^
<stdin>:3:36: error: No binary operator \"*\" for type \"vec3\" and type \"vec2\"
  vec2(0.0) * vec3(0.0); vec3(0.0) * vec2(0.0);
                                   ^
<stdin>:4:13: error: No binary operator \"*\" for type \"vec2\" and type \"vec4\"
  vec2(0.0) * vec4(0.0); vec4(0.0) * vec2(0.0);
            ^
<stdin>:4:36: error: No binary operator \"*\" for type \"vec4\" and type \"vec2\"
  vec2(0.0) * vec4(0.0); vec4(0.0) * vec2(0.0);
                                   ^
<stdin>:6:13: error: No binary operator \"*\" for type \"vec2\" and type \"mat3\"
  vec2(0.0) * mat3(0.0); mat3(0.0) * vec2(0.0);
            ^
<stdin>:6:36: error: No binary operator \"*\" for type \"mat3\" and type \"vec2\"
  vec2(0.0) * mat3(0.0); mat3(0.0) * vec2(0.0);
                                   ^
<stdin>:7:13: error: No binary operator \"*\" for type \"vec2\" and type \"mat4\"
  vec2(0.0) * mat4(0.0); mat4(0.0) * vec2(0.0);
            ^
<stdin>:7:36: error: No binary operator \"*\" for type \"mat4\" and type \"vec2\"
  vec2(0.0) * mat4(0.0); mat4(0.0) * vec2(0.0);
                                   ^
<stdin>:9:13: error: No binary operator \"*\" for type \"vec3\" and type \"vec2\"
  vec3(0.0) * vec2(0.0); vec2(0.0) * vec3(0.0);
            ^
<stdin>:9:36: error: No binary operator \"*\" for type \"vec2\" and type \"vec3\"
  vec3(0.0) * vec2(0.0); vec2(0.0) * vec3(0.0);
                                   ^
<stdin>:11:13: error: No binary operator \"*\" for type \"vec3\" and type \"vec4\"
  vec3(0.0) * vec4(0.0); vec4(0.0) * vec3(0.0);
            ^
<stdin>:11:36: error: No binary operator \"*\" for type \"vec4\" and type \"vec3\"
  vec3(0.0) * vec4(0.0); vec4(0.0) * vec3(0.0);
                                   ^
<stdin>:12:13: error: No binary operator \"*\" for type \"vec3\" and type \"mat2\"
  vec3(0.0) * mat2(0.0); mat2(0.0) * vec3(0.0);
            ^
<stdin>:12:36: error: No binary operator \"*\" for type \"mat2\" and type \"vec3\"
  vec3(0.0) * mat2(0.0); mat2(0.0) * vec3(0.0);
                                   ^
<stdin>:14:13: error: No binary operator \"*\" for type \"vec3\" and type \"mat4\"
  vec3(0.0) * mat4(0.0); mat4(0.0) * vec3(0.0);
            ^
<stdin>:14:36: error: No binary operator \"*\" for type \"mat4\" and type \"vec3\"
  vec3(0.0) * mat4(0.0); mat4(0.0) * vec3(0.0);
                                   ^
<stdin>:16:13: error: No binary operator \"*\" for type \"vec4\" and type \"vec2\"
  vec4(0.0) * vec2(0.0); vec2(0.0) * vec4(0.0);
            ^
<stdin>:16:36: error: No binary operator \"*\" for type \"vec2\" and type \"vec4\"
  vec4(0.0) * vec2(0.0); vec2(0.0) * vec4(0.0);
                                   ^
<stdin>:17:13: error: No binary operator \"*\" for type \"vec4\" and type \"vec3\"
  vec4(0.0) * vec3(0.0); vec3(0.0) * vec4(0.0);
            ^
<stdin>:17:36: error: No binary operator \"*\" for type \"vec3\" and type \"vec4\"
  vec4(0.0) * vec3(0.0); vec3(0.0) * vec4(0.0);
                                   ^
<stdin>:19:13: error: No binary operator \"*\" for type \"vec4\" and type \"mat2\"
  vec4(0.0) * mat2(0.0); mat2(0.0) * vec4(0.0);
            ^
<stdin>:19:36: error: No binary operator \"*\" for type \"mat2\" and type \"vec4\"
  vec4(0.0) * mat2(0.0); mat2(0.0) * vec4(0.0);
                                   ^
<stdin>:20:13: error: No binary operator \"*\" for type \"vec4\" and type \"mat3\"
  vec4(0.0) * mat3(0.0); mat3(0.0) * vec4(0.0);
            ^
<stdin>:20:36: error: No binary operator \"*\" for type \"mat3\" and type \"vec4\"
  vec4(0.0) * mat3(0.0); mat3(0.0) * vec4(0.0);
                                   ^
")

# Vector-matrix and matrix-vector division
test("
void main() {
  vec2(0.0) / vec2(0.0); vec2(0.0) / vec2(0.0);
  vec2(0.0) / vec3(0.0); vec3(0.0) / vec2(0.0);
  vec2(0.0) / vec4(0.0); vec4(0.0) / vec2(0.0);
  vec2(0.0) / mat2(0.0); mat2(0.0) / vec2(0.0);
  vec2(0.0) / mat3(0.0); mat3(0.0) / vec2(0.0);
  vec2(0.0) / mat4(0.0); mat4(0.0) / vec2(0.0);

  vec3(0.0) / vec2(0.0); vec2(0.0) / vec3(0.0);
  vec3(0.0) / vec3(0.0); vec3(0.0) / vec3(0.0);
  vec3(0.0) / vec4(0.0); vec4(0.0) / vec3(0.0);
  vec3(0.0) / mat2(0.0); mat2(0.0) / vec3(0.0);
  vec3(0.0) / mat3(0.0); mat3(0.0) / vec3(0.0);
  vec3(0.0) / mat4(0.0); mat4(0.0) / vec3(0.0);

  vec4(0.0) / vec2(0.0); vec2(0.0) / vec4(0.0);
  vec4(0.0) / vec3(0.0); vec3(0.0) / vec4(0.0);
  vec4(0.0) / vec4(0.0); vec4(0.0) / vec4(0.0);
  vec4(0.0) / mat2(0.0); mat2(0.0) / vec4(0.0);
  vec4(0.0) / mat3(0.0); mat3(0.0) / vec4(0.0);
  vec4(0.0) / mat4(0.0); mat4(0.0) / vec4(0.0);
}
", "
<stdin>:3:13: error: No binary operator \"/\" for type \"vec2\" and type \"vec3\"
  vec2(0.0) / vec3(0.0); vec3(0.0) / vec2(0.0);
            ^
<stdin>:3:36: error: No binary operator \"/\" for type \"vec3\" and type \"vec2\"
  vec2(0.0) / vec3(0.0); vec3(0.0) / vec2(0.0);
                                   ^
<stdin>:4:13: error: No binary operator \"/\" for type \"vec2\" and type \"vec4\"
  vec2(0.0) / vec4(0.0); vec4(0.0) / vec2(0.0);
            ^
<stdin>:4:36: error: No binary operator \"/\" for type \"vec4\" and type \"vec2\"
  vec2(0.0) / vec4(0.0); vec4(0.0) / vec2(0.0);
                                   ^
<stdin>:5:13: error: No binary operator \"/\" for type \"vec2\" and type \"mat2\"
  vec2(0.0) / mat2(0.0); mat2(0.0) / vec2(0.0);
            ^
<stdin>:5:36: error: No binary operator \"/\" for type \"mat2\" and type \"vec2\"
  vec2(0.0) / mat2(0.0); mat2(0.0) / vec2(0.0);
                                   ^
<stdin>:6:13: error: No binary operator \"/\" for type \"vec2\" and type \"mat3\"
  vec2(0.0) / mat3(0.0); mat3(0.0) / vec2(0.0);
            ^
<stdin>:6:36: error: No binary operator \"/\" for type \"mat3\" and type \"vec2\"
  vec2(0.0) / mat3(0.0); mat3(0.0) / vec2(0.0);
                                   ^
<stdin>:7:13: error: No binary operator \"/\" for type \"vec2\" and type \"mat4\"
  vec2(0.0) / mat4(0.0); mat4(0.0) / vec2(0.0);
            ^
<stdin>:7:36: error: No binary operator \"/\" for type \"mat4\" and type \"vec2\"
  vec2(0.0) / mat4(0.0); mat4(0.0) / vec2(0.0);
                                   ^
<stdin>:9:13: error: No binary operator \"/\" for type \"vec3\" and type \"vec2\"
  vec3(0.0) / vec2(0.0); vec2(0.0) / vec3(0.0);
            ^
<stdin>:9:36: error: No binary operator \"/\" for type \"vec2\" and type \"vec3\"
  vec3(0.0) / vec2(0.0); vec2(0.0) / vec3(0.0);
                                   ^
<stdin>:11:13: error: No binary operator \"/\" for type \"vec3\" and type \"vec4\"
  vec3(0.0) / vec4(0.0); vec4(0.0) / vec3(0.0);
            ^
<stdin>:11:36: error: No binary operator \"/\" for type \"vec4\" and type \"vec3\"
  vec3(0.0) / vec4(0.0); vec4(0.0) / vec3(0.0);
                                   ^
<stdin>:12:13: error: No binary operator \"/\" for type \"vec3\" and type \"mat2\"
  vec3(0.0) / mat2(0.0); mat2(0.0) / vec3(0.0);
            ^
<stdin>:12:36: error: No binary operator \"/\" for type \"mat2\" and type \"vec3\"
  vec3(0.0) / mat2(0.0); mat2(0.0) / vec3(0.0);
                                   ^
<stdin>:13:13: error: No binary operator \"/\" for type \"vec3\" and type \"mat3\"
  vec3(0.0) / mat3(0.0); mat3(0.0) / vec3(0.0);
            ^
<stdin>:13:36: error: No binary operator \"/\" for type \"mat3\" and type \"vec3\"
  vec3(0.0) / mat3(0.0); mat3(0.0) / vec3(0.0);
                                   ^
<stdin>:14:13: error: No binary operator \"/\" for type \"vec3\" and type \"mat4\"
  vec3(0.0) / mat4(0.0); mat4(0.0) / vec3(0.0);
            ^
<stdin>:14:36: error: No binary operator \"/\" for type \"mat4\" and type \"vec3\"
  vec3(0.0) / mat4(0.0); mat4(0.0) / vec3(0.0);
                                   ^
<stdin>:16:13: error: No binary operator \"/\" for type \"vec4\" and type \"vec2\"
  vec4(0.0) / vec2(0.0); vec2(0.0) / vec4(0.0);
            ^
<stdin>:16:36: error: No binary operator \"/\" for type \"vec2\" and type \"vec4\"
  vec4(0.0) / vec2(0.0); vec2(0.0) / vec4(0.0);
                                   ^
<stdin>:17:13: error: No binary operator \"/\" for type \"vec4\" and type \"vec3\"
  vec4(0.0) / vec3(0.0); vec3(0.0) / vec4(0.0);
            ^
<stdin>:17:36: error: No binary operator \"/\" for type \"vec3\" and type \"vec4\"
  vec4(0.0) / vec3(0.0); vec3(0.0) / vec4(0.0);
                                   ^
<stdin>:19:13: error: No binary operator \"/\" for type \"vec4\" and type \"mat2\"
  vec4(0.0) / mat2(0.0); mat2(0.0) / vec4(0.0);
            ^
<stdin>:19:36: error: No binary operator \"/\" for type \"mat2\" and type \"vec4\"
  vec4(0.0) / mat2(0.0); mat2(0.0) / vec4(0.0);
                                   ^
<stdin>:20:13: error: No binary operator \"/\" for type \"vec4\" and type \"mat3\"
  vec4(0.0) / mat3(0.0); mat3(0.0) / vec4(0.0);
            ^
<stdin>:20:36: error: No binary operator \"/\" for type \"mat3\" and type \"vec4\"
  vec4(0.0) / mat3(0.0); mat3(0.0) / vec4(0.0);
                                   ^
<stdin>:21:13: error: No binary operator \"/\" for type \"vec4\" and type \"mat4\"
  vec4(0.0) / mat4(0.0); mat4(0.0) / vec4(0.0);
            ^
<stdin>:21:36: error: No binary operator \"/\" for type \"mat4\" and type \"vec4\"
  vec4(0.0) / mat4(0.0); mat4(0.0) / vec4(0.0);
                                   ^
")

# Assignment addition
test("
void main(vec2 v2, vec3 v3, vec4 v4, mat2 m2, mat3 m3, mat4 m4) {
  v2 += v2;
  v2 += v3;
  v2 += v4;
  v2 += m2;
  v2 += m3;
  v2 += m4;

  v3 += v2;
  v3 += v3;
  v3 += v4;
  v3 += m2;
  v3 += m3;
  v3 += m4;

  v4 += v2;
  v4 += v3;
  v4 += v4;
  v4 += m2;
  v4 += m3;
  v4 += m4;

  m2 += v2;
  m2 += v3;
  m2 += v4;
  m2 += m2;
  m2 += m3;
  m2 += m4;

  m3 += v2;
  m3 += v3;
  m3 += v4;
  m3 += m2;
  m3 += m3;
  m3 += m4;

  m4 += v2;
  m4 += v3;
  m4 += v4;
  m4 += m2;
  m4 += m3;
  m4 += m4;
}
", "
<stdin>:3:6: error: No binary operator \"+=\" for type \"vec2\" and type \"vec3\"
  v2 += v3;
     ~~
<stdin>:4:6: error: No binary operator \"+=\" for type \"vec2\" and type \"vec4\"
  v2 += v4;
     ~~
<stdin>:5:6: error: No binary operator \"+=\" for type \"vec2\" and type \"mat2\"
  v2 += m2;
     ~~
<stdin>:6:6: error: No binary operator \"+=\" for type \"vec2\" and type \"mat3\"
  v2 += m3;
     ~~
<stdin>:7:6: error: No binary operator \"+=\" for type \"vec2\" and type \"mat4\"
  v2 += m4;
     ~~
<stdin>:9:6: error: No binary operator \"+=\" for type \"vec3\" and type \"vec2\"
  v3 += v2;
     ~~
<stdin>:11:6: error: No binary operator \"+=\" for type \"vec3\" and type \"vec4\"
  v3 += v4;
     ~~
<stdin>:12:6: error: No binary operator \"+=\" for type \"vec3\" and type \"mat2\"
  v3 += m2;
     ~~
<stdin>:13:6: error: No binary operator \"+=\" for type \"vec3\" and type \"mat3\"
  v3 += m3;
     ~~
<stdin>:14:6: error: No binary operator \"+=\" for type \"vec3\" and type \"mat4\"
  v3 += m4;
     ~~
<stdin>:16:6: error: No binary operator \"+=\" for type \"vec4\" and type \"vec2\"
  v4 += v2;
     ~~
<stdin>:17:6: error: No binary operator \"+=\" for type \"vec4\" and type \"vec3\"
  v4 += v3;
     ~~
<stdin>:19:6: error: No binary operator \"+=\" for type \"vec4\" and type \"mat2\"
  v4 += m2;
     ~~
<stdin>:20:6: error: No binary operator \"+=\" for type \"vec4\" and type \"mat3\"
  v4 += m3;
     ~~
<stdin>:21:6: error: No binary operator \"+=\" for type \"vec4\" and type \"mat4\"
  v4 += m4;
     ~~
<stdin>:23:6: error: No binary operator \"+=\" for type \"mat2\" and type \"vec2\"
  m2 += v2;
     ~~
<stdin>:24:6: error: No binary operator \"+=\" for type \"mat2\" and type \"vec3\"
  m2 += v3;
     ~~
<stdin>:25:6: error: No binary operator \"+=\" for type \"mat2\" and type \"vec4\"
  m2 += v4;
     ~~
<stdin>:27:6: error: No binary operator \"+=\" for type \"mat2\" and type \"mat3\"
  m2 += m3;
     ~~
<stdin>:28:6: error: No binary operator \"+=\" for type \"mat2\" and type \"mat4\"
  m2 += m4;
     ~~
<stdin>:30:6: error: No binary operator \"+=\" for type \"mat3\" and type \"vec2\"
  m3 += v2;
     ~~
<stdin>:31:6: error: No binary operator \"+=\" for type \"mat3\" and type \"vec3\"
  m3 += v3;
     ~~
<stdin>:32:6: error: No binary operator \"+=\" for type \"mat3\" and type \"vec4\"
  m3 += v4;
     ~~
<stdin>:33:6: error: No binary operator \"+=\" for type \"mat3\" and type \"mat2\"
  m3 += m2;
     ~~
<stdin>:35:6: error: No binary operator \"+=\" for type \"mat3\" and type \"mat4\"
  m3 += m4;
     ~~
<stdin>:37:6: error: No binary operator \"+=\" for type \"mat4\" and type \"vec2\"
  m4 += v2;
     ~~
<stdin>:38:6: error: No binary operator \"+=\" for type \"mat4\" and type \"vec3\"
  m4 += v3;
     ~~
<stdin>:39:6: error: No binary operator \"+=\" for type \"mat4\" and type \"vec4\"
  m4 += v4;
     ~~
<stdin>:40:6: error: No binary operator \"+=\" for type \"mat4\" and type \"mat2\"
  m4 += m2;
     ~~
<stdin>:41:6: error: No binary operator \"+=\" for type \"mat4\" and type \"mat3\"
  m4 += m3;
     ~~
")

# Assignment subtraction
test("
void main(vec2 v2, vec3 v3, vec4 v4, mat2 m2, mat3 m3, mat4 m4) {
  v2 -= v2;
  v2 -= v3;
  v2 -= v4;
  v2 -= m2;
  v2 -= m3;
  v2 -= m4;

  v3 -= v2;
  v3 -= v3;
  v3 -= v4;
  v3 -= m2;
  v3 -= m3;
  v3 -= m4;

  v4 -= v2;
  v4 -= v3;
  v4 -= v4;
  v4 -= m2;
  v4 -= m3;
  v4 -= m4;

  m2 -= v2;
  m2 -= v3;
  m2 -= v4;
  m2 -= m2;
  m2 -= m3;
  m2 -= m4;

  m3 -= v2;
  m3 -= v3;
  m3 -= v4;
  m3 -= m2;
  m3 -= m3;
  m3 -= m4;

  m4 -= v2;
  m4 -= v3;
  m4 -= v4;
  m4 -= m2;
  m4 -= m3;
  m4 -= m4;
}
", "
<stdin>:3:6: error: No binary operator \"-=\" for type \"vec2\" and type \"vec3\"
  v2 -= v3;
     ~~
<stdin>:4:6: error: No binary operator \"-=\" for type \"vec2\" and type \"vec4\"
  v2 -= v4;
     ~~
<stdin>:5:6: error: No binary operator \"-=\" for type \"vec2\" and type \"mat2\"
  v2 -= m2;
     ~~
<stdin>:6:6: error: No binary operator \"-=\" for type \"vec2\" and type \"mat3\"
  v2 -= m3;
     ~~
<stdin>:7:6: error: No binary operator \"-=\" for type \"vec2\" and type \"mat4\"
  v2 -= m4;
     ~~
<stdin>:9:6: error: No binary operator \"-=\" for type \"vec3\" and type \"vec2\"
  v3 -= v2;
     ~~
<stdin>:11:6: error: No binary operator \"-=\" for type \"vec3\" and type \"vec4\"
  v3 -= v4;
     ~~
<stdin>:12:6: error: No binary operator \"-=\" for type \"vec3\" and type \"mat2\"
  v3 -= m2;
     ~~
<stdin>:13:6: error: No binary operator \"-=\" for type \"vec3\" and type \"mat3\"
  v3 -= m3;
     ~~
<stdin>:14:6: error: No binary operator \"-=\" for type \"vec3\" and type \"mat4\"
  v3 -= m4;
     ~~
<stdin>:16:6: error: No binary operator \"-=\" for type \"vec4\" and type \"vec2\"
  v4 -= v2;
     ~~
<stdin>:17:6: error: No binary operator \"-=\" for type \"vec4\" and type \"vec3\"
  v4 -= v3;
     ~~
<stdin>:19:6: error: No binary operator \"-=\" for type \"vec4\" and type \"mat2\"
  v4 -= m2;
     ~~
<stdin>:20:6: error: No binary operator \"-=\" for type \"vec4\" and type \"mat3\"
  v4 -= m3;
     ~~
<stdin>:21:6: error: No binary operator \"-=\" for type \"vec4\" and type \"mat4\"
  v4 -= m4;
     ~~
<stdin>:23:6: error: No binary operator \"-=\" for type \"mat2\" and type \"vec2\"
  m2 -= v2;
     ~~
<stdin>:24:6: error: No binary operator \"-=\" for type \"mat2\" and type \"vec3\"
  m2 -= v3;
     ~~
<stdin>:25:6: error: No binary operator \"-=\" for type \"mat2\" and type \"vec4\"
  m2 -= v4;
     ~~
<stdin>:27:6: error: No binary operator \"-=\" for type \"mat2\" and type \"mat3\"
  m2 -= m3;
     ~~
<stdin>:28:6: error: No binary operator \"-=\" for type \"mat2\" and type \"mat4\"
  m2 -= m4;
     ~~
<stdin>:30:6: error: No binary operator \"-=\" for type \"mat3\" and type \"vec2\"
  m3 -= v2;
     ~~
<stdin>:31:6: error: No binary operator \"-=\" for type \"mat3\" and type \"vec3\"
  m3 -= v3;
     ~~
<stdin>:32:6: error: No binary operator \"-=\" for type \"mat3\" and type \"vec4\"
  m3 -= v4;
     ~~
<stdin>:33:6: error: No binary operator \"-=\" for type \"mat3\" and type \"mat2\"
  m3 -= m2;
     ~~
<stdin>:35:6: error: No binary operator \"-=\" for type \"mat3\" and type \"mat4\"
  m3 -= m4;
     ~~
<stdin>:37:6: error: No binary operator \"-=\" for type \"mat4\" and type \"vec2\"
  m4 -= v2;
     ~~
<stdin>:38:6: error: No binary operator \"-=\" for type \"mat4\" and type \"vec3\"
  m4 -= v3;
     ~~
<stdin>:39:6: error: No binary operator \"-=\" for type \"mat4\" and type \"vec4\"
  m4 -= v4;
     ~~
<stdin>:40:6: error: No binary operator \"-=\" for type \"mat4\" and type \"mat2\"
  m4 -= m2;
     ~~
<stdin>:41:6: error: No binary operator \"-=\" for type \"mat4\" and type \"mat3\"
  m4 -= m3;
     ~~
")

# Assignment multiplication
test("
void main(vec2 v2, vec3 v3, vec4 v4, mat2 m2, mat3 m3, mat4 m4) {
  v2 *= v2;
  v2 *= v3;
  v2 *= v4;
  v2 *= m2;
  v2 *= m3;
  v2 *= m4;

  v3 *= v2;
  v3 *= v3;
  v3 *= v4;
  v3 *= m2;
  v3 *= m3;
  v3 *= m4;

  v4 *= v2;
  v4 *= v3;
  v4 *= v4;
  v4 *= m2;
  v4 *= m3;
  v4 *= m4;

  m2 *= v2;
  m2 *= v3;
  m2 *= v4;
  m2 *= m2;
  m2 *= m3;
  m2 *= m4;

  m3 *= v2;
  m3 *= v3;
  m3 *= v4;
  m3 *= m2;
  m3 *= m3;
  m3 *= m4;

  m4 *= v2;
  m4 *= v3;
  m4 *= v4;
  m4 *= m2;
  m4 *= m3;
  m4 *= m4;
}
", "
<stdin>:3:6: error: No binary operator \"*=\" for type \"vec2\" and type \"vec3\"
  v2 *= v3;
     ~~
<stdin>:4:6: error: No binary operator \"*=\" for type \"vec2\" and type \"vec4\"
  v2 *= v4;
     ~~
<stdin>:6:6: error: No binary operator \"*=\" for type \"vec2\" and type \"mat3\"
  v2 *= m3;
     ~~
<stdin>:7:6: error: No binary operator \"*=\" for type \"vec2\" and type \"mat4\"
  v2 *= m4;
     ~~
<stdin>:9:6: error: No binary operator \"*=\" for type \"vec3\" and type \"vec2\"
  v3 *= v2;
     ~~
<stdin>:11:6: error: No binary operator \"*=\" for type \"vec3\" and type \"vec4\"
  v3 *= v4;
     ~~
<stdin>:12:6: error: No binary operator \"*=\" for type \"vec3\" and type \"mat2\"
  v3 *= m2;
     ~~
<stdin>:14:6: error: No binary operator \"*=\" for type \"vec3\" and type \"mat4\"
  v3 *= m4;
     ~~
<stdin>:16:6: error: No binary operator \"*=\" for type \"vec4\" and type \"vec2\"
  v4 *= v2;
     ~~
<stdin>:17:6: error: No binary operator \"*=\" for type \"vec4\" and type \"vec3\"
  v4 *= v3;
     ~~
<stdin>:19:6: error: No binary operator \"*=\" for type \"vec4\" and type \"mat2\"
  v4 *= m2;
     ~~
<stdin>:20:6: error: No binary operator \"*=\" for type \"vec4\" and type \"mat3\"
  v4 *= m3;
     ~~
<stdin>:23:6: error: No binary operator \"*=\" for type \"mat2\" and type \"vec2\"
  m2 *= v2;
     ~~
<stdin>:24:6: error: No binary operator \"*=\" for type \"mat2\" and type \"vec3\"
  m2 *= v3;
     ~~
<stdin>:25:6: error: No binary operator \"*=\" for type \"mat2\" and type \"vec4\"
  m2 *= v4;
     ~~
<stdin>:27:6: error: No binary operator \"*=\" for type \"mat2\" and type \"mat3\"
  m2 *= m3;
     ~~
<stdin>:28:6: error: No binary operator \"*=\" for type \"mat2\" and type \"mat4\"
  m2 *= m4;
     ~~
<stdin>:30:6: error: No binary operator \"*=\" for type \"mat3\" and type \"vec2\"
  m3 *= v2;
     ~~
<stdin>:31:6: error: No binary operator \"*=\" for type \"mat3\" and type \"vec3\"
  m3 *= v3;
     ~~
<stdin>:32:6: error: No binary operator \"*=\" for type \"mat3\" and type \"vec4\"
  m3 *= v4;
     ~~
<stdin>:33:6: error: No binary operator \"*=\" for type \"mat3\" and type \"mat2\"
  m3 *= m2;
     ~~
<stdin>:35:6: error: No binary operator \"*=\" for type \"mat3\" and type \"mat4\"
  m3 *= m4;
     ~~
<stdin>:37:6: error: No binary operator \"*=\" for type \"mat4\" and type \"vec2\"
  m4 *= v2;
     ~~
<stdin>:38:6: error: No binary operator \"*=\" for type \"mat4\" and type \"vec3\"
  m4 *= v3;
     ~~
<stdin>:39:6: error: No binary operator \"*=\" for type \"mat4\" and type \"vec4\"
  m4 *= v4;
     ~~
<stdin>:40:6: error: No binary operator \"*=\" for type \"mat4\" and type \"mat2\"
  m4 *= m2;
     ~~
<stdin>:41:6: error: No binary operator \"*=\" for type \"mat4\" and type \"mat3\"
  m4 *= m3;
     ~~
")

# Assignment division
test("
void main(vec2 v2, vec3 v3, vec4 v4, mat2 m2, mat3 m3, mat4 m4) {
  v2 /= v2;
  v2 /= v3;
  v2 /= v4;
  v2 /= m2;
  v2 /= m3;
  v2 /= m4;

  v3 /= v2;
  v3 /= v3;
  v3 /= v4;
  v3 /= m2;
  v3 /= m3;
  v3 /= m4;

  v4 /= v2;
  v4 /= v3;
  v4 /= v4;
  v4 /= m2;
  v4 /= m3;
  v4 /= m4;

  m2 /= v2;
  m2 /= v3;
  m2 /= v4;
  m2 /= m2;
  m2 /= m3;
  m2 /= m4;

  m3 /= v2;
  m3 /= v3;
  m3 /= v4;
  m3 /= m2;
  m3 /= m3;
  m3 /= m4;

  m4 /= v2;
  m4 /= v3;
  m4 /= v4;
  m4 /= m2;
  m4 /= m3;
  m4 /= m4;
}
", "
<stdin>:3:6: error: No binary operator \"/=\" for type \"vec2\" and type \"vec3\"
  v2 /= v3;
     ~~
<stdin>:4:6: error: No binary operator \"/=\" for type \"vec2\" and type \"vec4\"
  v2 /= v4;
     ~~
<stdin>:5:6: error: No binary operator \"/=\" for type \"vec2\" and type \"mat2\"
  v2 /= m2;
     ~~
<stdin>:6:6: error: No binary operator \"/=\" for type \"vec2\" and type \"mat3\"
  v2 /= m3;
     ~~
<stdin>:7:6: error: No binary operator \"/=\" for type \"vec2\" and type \"mat4\"
  v2 /= m4;
     ~~
<stdin>:9:6: error: No binary operator \"/=\" for type \"vec3\" and type \"vec2\"
  v3 /= v2;
     ~~
<stdin>:11:6: error: No binary operator \"/=\" for type \"vec3\" and type \"vec4\"
  v3 /= v4;
     ~~
<stdin>:12:6: error: No binary operator \"/=\" for type \"vec3\" and type \"mat2\"
  v3 /= m2;
     ~~
<stdin>:13:6: error: No binary operator \"/=\" for type \"vec3\" and type \"mat3\"
  v3 /= m3;
     ~~
<stdin>:14:6: error: No binary operator \"/=\" for type \"vec3\" and type \"mat4\"
  v3 /= m4;
     ~~
<stdin>:16:6: error: No binary operator \"/=\" for type \"vec4\" and type \"vec2\"
  v4 /= v2;
     ~~
<stdin>:17:6: error: No binary operator \"/=\" for type \"vec4\" and type \"vec3\"
  v4 /= v3;
     ~~
<stdin>:19:6: error: No binary operator \"/=\" for type \"vec4\" and type \"mat2\"
  v4 /= m2;
     ~~
<stdin>:20:6: error: No binary operator \"/=\" for type \"vec4\" and type \"mat3\"
  v4 /= m3;
     ~~
<stdin>:21:6: error: No binary operator \"/=\" for type \"vec4\" and type \"mat4\"
  v4 /= m4;
     ~~
<stdin>:23:6: error: No binary operator \"/=\" for type \"mat2\" and type \"vec2\"
  m2 /= v2;
     ~~
<stdin>:24:6: error: No binary operator \"/=\" for type \"mat2\" and type \"vec3\"
  m2 /= v3;
     ~~
<stdin>:25:6: error: No binary operator \"/=\" for type \"mat2\" and type \"vec4\"
  m2 /= v4;
     ~~
<stdin>:27:6: error: No binary operator \"/=\" for type \"mat2\" and type \"mat3\"
  m2 /= m3;
     ~~
<stdin>:28:6: error: No binary operator \"/=\" for type \"mat2\" and type \"mat4\"
  m2 /= m4;
     ~~
<stdin>:30:6: error: No binary operator \"/=\" for type \"mat3\" and type \"vec2\"
  m3 /= v2;
     ~~
<stdin>:31:6: error: No binary operator \"/=\" for type \"mat3\" and type \"vec3\"
  m3 /= v3;
     ~~
<stdin>:32:6: error: No binary operator \"/=\" for type \"mat3\" and type \"vec4\"
  m3 /= v4;
     ~~
<stdin>:33:6: error: No binary operator \"/=\" for type \"mat3\" and type \"mat2\"
  m3 /= m2;
     ~~
<stdin>:35:6: error: No binary operator \"/=\" for type \"mat3\" and type \"mat4\"
  m3 /= m4;
     ~~
<stdin>:37:6: error: No binary operator \"/=\" for type \"mat4\" and type \"vec2\"
  m4 /= v2;
     ~~
<stdin>:38:6: error: No binary operator \"/=\" for type \"mat4\" and type \"vec3\"
  m4 /= v3;
     ~~
<stdin>:39:6: error: No binary operator \"/=\" for type \"mat4\" and type \"vec4\"
  m4 /= v4;
     ~~
<stdin>:40:6: error: No binary operator \"/=\" for type \"mat4\" and type \"mat2\"
  m4 /= m2;
     ~~
<stdin>:41:6: error: No binary operator \"/=\" for type \"mat4\" and type \"mat3\"
  m4 /= m3;
     ~~
")

# Assignment multiplication
test("
void main(vec2 v2, vec3 v3, vec4 v4, mat2 m2, mat3 m3, mat4 m4) {
  v2 *= v2;
  v2 *= v3;
  v2 *= v4;
  v2 *= m2;
  v2 *= m3;
  v2 *= m4;

  v3 *= v2;
  v3 *= v3;
  v3 *= v4;
  v3 *= m2;
  v3 *= m3;
  v3 *= m4;

  v4 *= v2;
  v4 *= v3;
  v4 *= v4;
  v4 *= m2;
  v4 *= m3;
  v4 *= m4;

  m2 *= v2;
  m2 *= v3;
  m2 *= v4;
  m2 *= m2;
  m2 *= m3;
  m2 *= m4;

  m3 *= v2;
  m3 *= v3;
  m3 *= v4;
  m3 *= m2;
  m3 *= m3;
  m3 *= m4;

  m4 *= v2;
  m4 *= v3;
  m4 *= v4;
  m4 *= m2;
  m4 *= m3;
  m4 *= m4;
}
", "
<stdin>:3:6: error: No binary operator \"*=\" for type \"vec2\" and type \"vec3\"
  v2 *= v3;
     ~~
<stdin>:4:6: error: No binary operator \"*=\" for type \"vec2\" and type \"vec4\"
  v2 *= v4;
     ~~
<stdin>:6:6: error: No binary operator \"*=\" for type \"vec2\" and type \"mat3\"
  v2 *= m3;
     ~~
<stdin>:7:6: error: No binary operator \"*=\" for type \"vec2\" and type \"mat4\"
  v2 *= m4;
     ~~
<stdin>:9:6: error: No binary operator \"*=\" for type \"vec3\" and type \"vec2\"
  v3 *= v2;
     ~~
<stdin>:11:6: error: No binary operator \"*=\" for type \"vec3\" and type \"vec4\"
  v3 *= v4;
     ~~
<stdin>:12:6: error: No binary operator \"*=\" for type \"vec3\" and type \"mat2\"
  v3 *= m2;
     ~~
<stdin>:14:6: error: No binary operator \"*=\" for type \"vec3\" and type \"mat4\"
  v3 *= m4;
     ~~
<stdin>:16:6: error: No binary operator \"*=\" for type \"vec4\" and type \"vec2\"
  v4 *= v2;
     ~~
<stdin>:17:6: error: No binary operator \"*=\" for type \"vec4\" and type \"vec3\"
  v4 *= v3;
     ~~
<stdin>:19:6: error: No binary operator \"*=\" for type \"vec4\" and type \"mat2\"
  v4 *= m2;
     ~~
<stdin>:20:6: error: No binary operator \"*=\" for type \"vec4\" and type \"mat3\"
  v4 *= m3;
     ~~
<stdin>:23:6: error: No binary operator \"*=\" for type \"mat2\" and type \"vec2\"
  m2 *= v2;
     ~~
<stdin>:24:6: error: No binary operator \"*=\" for type \"mat2\" and type \"vec3\"
  m2 *= v3;
     ~~
<stdin>:25:6: error: No binary operator \"*=\" for type \"mat2\" and type \"vec4\"
  m2 *= v4;
     ~~
<stdin>:27:6: error: No binary operator \"*=\" for type \"mat2\" and type \"mat3\"
  m2 *= m3;
     ~~
<stdin>:28:6: error: No binary operator \"*=\" for type \"mat2\" and type \"mat4\"
  m2 *= m4;
     ~~
<stdin>:30:6: error: No binary operator \"*=\" for type \"mat3\" and type \"vec2\"
  m3 *= v2;
     ~~
<stdin>:31:6: error: No binary operator \"*=\" for type \"mat3\" and type \"vec3\"
  m3 *= v3;
     ~~
<stdin>:32:6: error: No binary operator \"*=\" for type \"mat3\" and type \"vec4\"
  m3 *= v4;
     ~~
<stdin>:33:6: error: No binary operator \"*=\" for type \"mat3\" and type \"mat2\"
  m3 *= m2;
     ~~
<stdin>:35:6: error: No binary operator \"*=\" for type \"mat3\" and type \"mat4\"
  m3 *= m4;
     ~~
<stdin>:37:6: error: No binary operator \"*=\" for type \"mat4\" and type \"vec2\"
  m4 *= v2;
     ~~
<stdin>:38:6: error: No binary operator \"*=\" for type \"mat4\" and type \"vec3\"
  m4 *= v3;
     ~~
<stdin>:39:6: error: No binary operator \"*=\" for type \"mat4\" and type \"vec4\"
  m4 *= v4;
     ~~
<stdin>:40:6: error: No binary operator \"*=\" for type \"mat4\" and type \"mat2\"
  m4 *= m2;
     ~~
<stdin>:41:6: error: No binary operator \"*=\" for type \"mat4\" and type \"mat3\"
  m4 *= m3;
     ~~
")

# Index type checking
test("
void main() {
  0[0];
  vec2(0.0)[false];
}
", "
<stdin>:2:4: error: No index operator for type \"int\" and type \"int\"
  0[0];
   ~~~
<stdin>:3:12: error: No index operator for type \"vec2\" and type \"bool\"
  vec2(0.0)[false];
           ~~~~~~~
")

# Index type range checking
test("
void main() {
  int x[-1];
  int y[0];
  int z[1];
}
", "
<stdin>:2:9: error: Cannot declare an array with a size of \"-1\"
  int x[-1];
        ~~
<stdin>:3:9: error: Cannot declare an array with a size of \"0\"
  int y[0];
        ^
")

# Index range checking
test("
void main() {
  const int N = 2;
  int x[2];
  int y[N];
  vec2 v;
  mat2 m;
  x[0] = x[1];
  y[0] = y[1];
  v[0] = v[1];
  m[0] = m[1];
  m[0][1] = m[1][0];
  x[-1] = x[2];
  y[-1] = y[2];
  v[-1] = v[2];
  m[-1] = m[2];
  m[-1][2] = m[2][-1];
}
", "
<stdin>:12:5: error: Index \"-1\" is out of bounds for type \"int[2]\"
  x[-1] = x[2];
    ~~
<stdin>:12:13: error: Index \"2\" is out of bounds for type \"int[2]\"
  x[-1] = x[2];
            ^
<stdin>:13:5: error: Index \"-1\" is out of bounds for type \"int[2]\"
  y[-1] = y[2];
    ~~
<stdin>:13:13: error: Index \"2\" is out of bounds for type \"int[2]\"
  y[-1] = y[2];
            ^
<stdin>:14:5: error: Index \"-1\" is out of bounds for type \"vec2\"
  v[-1] = v[2];
    ~~
<stdin>:14:13: error: Index \"2\" is out of bounds for type \"vec2\"
  v[-1] = v[2];
            ^
<stdin>:15:5: error: Index \"-1\" is out of bounds for type \"mat2\"
  m[-1] = m[2];
    ~~
<stdin>:15:13: error: Index \"2\" is out of bounds for type \"mat2\"
  m[-1] = m[2];
            ^
<stdin>:16:5: error: Index \"-1\" is out of bounds for type \"mat2\"
  m[-1][2] = m[2][-1];
    ~~
<stdin>:16:9: error: Index \"2\" is out of bounds for type \"vec2\"
  m[-1][2] = m[2][-1];
        ^
<stdin>:16:16: error: Index \"2\" is out of bounds for type \"mat2\"
  m[-1][2] = m[2][-1];
               ^
<stdin>:16:19: error: Index \"-1\" is out of bounds for type \"vec2\"
  m[-1][2] = m[2][-1];
                  ~~
")

# Avoid emitting index range checks for unknown sizes
test("
const int unknownCount;
float unknownArray[unknownCount];

void main() {
  unknownArray[0] = unknownArray[1];
  unknownArray[-1] = unknownArray[2];
}
", "
<stdin>:6:16: error: Index \"-1\" is out of bounds for type \"float[]\"
  unknownArray[-1] = unknownArray[2];
               ~~
")

# Check types of indexed values
test("
void main() {
  int v20 = vec2(0.0)[0];
  int v30 = vec3(0.0)[0];
  int v40 = vec4(0.0)[0];

  int m20 = mat2(0.0)[0];
  int m30 = mat3(0.0)[0];
  int m40 = mat4(0.0)[0];

  int m200 = mat2(0.0)[0][0];
  int m300 = mat3(0.0)[0][0];
  int m400 = mat4(0.0)[0][0];

  bool i20 = ivec2(0)[0];
  bool i30 = ivec3(0)[0];
  bool i40 = ivec4(0)[0];

  int b20 = bvec2(false)[0];
  int b30 = bvec3(false)[0];
  int b40 = bvec4(false)[0];
}
", "
<stdin>:2:13: error: Cannot convert from type \"float\" to type \"int\"
  int v20 = vec2(0.0)[0];
            ~~~~~~~~~~~~
<stdin>:3:13: error: Cannot convert from type \"float\" to type \"int\"
  int v30 = vec3(0.0)[0];
            ~~~~~~~~~~~~
<stdin>:4:13: error: Cannot convert from type \"float\" to type \"int\"
  int v40 = vec4(0.0)[0];
            ~~~~~~~~~~~~
<stdin>:6:13: error: Cannot convert from type \"vec2\" to type \"int\"
  int m20 = mat2(0.0)[0];
            ~~~~~~~~~~~~
<stdin>:7:13: error: Cannot convert from type \"vec3\" to type \"int\"
  int m30 = mat3(0.0)[0];
            ~~~~~~~~~~~~
<stdin>:8:13: error: Cannot convert from type \"vec4\" to type \"int\"
  int m40 = mat4(0.0)[0];
            ~~~~~~~~~~~~
<stdin>:10:14: error: Cannot convert from type \"float\" to type \"int\"
  int m200 = mat2(0.0)[0][0];
             ~~~~~~~~~~~~~~~
<stdin>:11:14: error: Cannot convert from type \"float\" to type \"int\"
  int m300 = mat3(0.0)[0][0];
             ~~~~~~~~~~~~~~~
<stdin>:12:14: error: Cannot convert from type \"float\" to type \"int\"
  int m400 = mat4(0.0)[0][0];
             ~~~~~~~~~~~~~~~
<stdin>:14:14: error: Cannot convert from type \"int\" to type \"bool\"
  bool i20 = ivec2(0)[0];
             ~~~~~~~~~~~
<stdin>:15:14: error: Cannot convert from type \"int\" to type \"bool\"
  bool i30 = ivec3(0)[0];
             ~~~~~~~~~~~
<stdin>:16:14: error: Cannot convert from type \"int\" to type \"bool\"
  bool i40 = ivec4(0)[0];
             ~~~~~~~~~~~
<stdin>:18:13: error: Cannot convert from type \"bool\" to type \"int\"
  int b20 = bvec2(false)[0];
            ~~~~~~~~~~~~~~~
<stdin>:19:13: error: Cannot convert from type \"bool\" to type \"int\"
  int b30 = bvec3(false)[0];
            ~~~~~~~~~~~~~~~
<stdin>:20:13: error: Cannot convert from type \"bool\" to type \"int\"
  int b40 = bvec4(false)[0];
            ~~~~~~~~~~~~~~~
")

# Check single swizzles
test("
void main(vec2 v2, vec3 v3, vec4 v4) {
  int v20 = v2.x + v2.r + v2.s;
  int v21 = v2.y + v2.g + v2.t;
  int v22 = v2.z + v2.b + v2.p;
  int v23 = v2.w + v2.a + v2.q;

  int v30 = v3.x + v3.r + v3.s;
  int v31 = v3.y + v3.g + v3.t;
  int v32 = v3.z + v3.b + v3.p;
  int v33 = v3.w + v3.a + v3.q;

  int v40 = v4.x + v4.r + v4.s;
  int v41 = v4.y + v4.g + v4.t;
  int v42 = v4.z + v4.b + v4.p;
  int v43 = v4.w + v4.a + v4.q;
}
", "
<stdin>:2:13: error: Cannot convert from type \"float\" to type \"int\"
  int v20 = v2.x + v2.r + v2.s;
            ~~~~~~~~~~~~~~~~~~
<stdin>:3:13: error: Cannot convert from type \"float\" to type \"int\"
  int v21 = v2.y + v2.g + v2.t;
            ~~~~~~~~~~~~~~~~~~
<stdin>:4:16: error: Invalid swizzle \"z\" on type \"vec2\"
  int v22 = v2.z + v2.b + v2.p;
               ^
<stdin>:4:23: error: Invalid swizzle \"b\" on type \"vec2\"
  int v22 = v2.z + v2.b + v2.p;
                      ^
<stdin>:4:30: error: Invalid swizzle \"p\" on type \"vec2\"
  int v22 = v2.z + v2.b + v2.p;
                             ^
<stdin>:5:16: error: Invalid swizzle \"w\" on type \"vec2\"
  int v23 = v2.w + v2.a + v2.q;
               ^
<stdin>:5:23: error: Invalid swizzle \"a\" on type \"vec2\"
  int v23 = v2.w + v2.a + v2.q;
                      ^
<stdin>:5:30: error: Invalid swizzle \"q\" on type \"vec2\"
  int v23 = v2.w + v2.a + v2.q;
                             ^
<stdin>:7:13: error: Cannot convert from type \"float\" to type \"int\"
  int v30 = v3.x + v3.r + v3.s;
            ~~~~~~~~~~~~~~~~~~
<stdin>:8:13: error: Cannot convert from type \"float\" to type \"int\"
  int v31 = v3.y + v3.g + v3.t;
            ~~~~~~~~~~~~~~~~~~
<stdin>:9:13: error: Cannot convert from type \"float\" to type \"int\"
  int v32 = v3.z + v3.b + v3.p;
            ~~~~~~~~~~~~~~~~~~
<stdin>:10:16: error: Invalid swizzle \"w\" on type \"vec3\"
  int v33 = v3.w + v3.a + v3.q;
               ^
<stdin>:10:23: error: Invalid swizzle \"a\" on type \"vec3\"
  int v33 = v3.w + v3.a + v3.q;
                      ^
<stdin>:10:30: error: Invalid swizzle \"q\" on type \"vec3\"
  int v33 = v3.w + v3.a + v3.q;
                             ^
<stdin>:12:13: error: Cannot convert from type \"float\" to type \"int\"
  int v40 = v4.x + v4.r + v4.s;
            ~~~~~~~~~~~~~~~~~~
<stdin>:13:13: error: Cannot convert from type \"float\" to type \"int\"
  int v41 = v4.y + v4.g + v4.t;
            ~~~~~~~~~~~~~~~~~~
<stdin>:14:13: error: Cannot convert from type \"float\" to type \"int\"
  int v42 = v4.z + v4.b + v4.p;
            ~~~~~~~~~~~~~~~~~~
<stdin>:15:13: error: Cannot convert from type \"float\" to type \"int\"
  int v43 = v4.w + v4.a + v4.q;
            ~~~~~~~~~~~~~~~~~~
")

# Check compound swizzles
test("
void main(vec2 v2, vec3 v3, vec4 v4) {
  int v2xy = v2.xy + v2.yx;
  int v3xyz = v3.xyz + v3.xzy + v3.yxz + v3.yzx + v3.zxy + v3.zyx;
  int v4xyzw = v4.xyzw + v4.wxyz + v4.zwxy + v4.yzwx;

  int v234rr = v2.rr + v2.rr + v4.rr;
  int v234ssst = v2.ssst + v2.ssst + v4.ssst;

  int v2xyz = v2.xyz + v2.zyx;
  int v3xyzw = v3.xyzw + v3.wzyx;

  v2.rr = v3.rr;
  v3.sts = v4.sts;
  v4.xx = v2.xx;
}
", "
<stdin>:2:14: error: Cannot convert from type \"vec2\" to type \"int\"
  int v2xy = v2.xy + v2.yx;
             ~~~~~~~~~~~~~
<stdin>:3:15: error: Cannot convert from type \"vec3\" to type \"int\"
  int v3xyz = v3.xyz + v3.xzy + v3.yxz + v3.yzx + v3.zxy + v3.zyx;
              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:4:16: error: Cannot convert from type \"vec4\" to type \"int\"
  int v4xyzw = v4.xyzw + v4.wxyz + v4.zwxy + v4.yzwx;
               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:6:16: error: Cannot convert from type \"vec2\" to type \"int\"
  int v234rr = v2.rr + v2.rr + v4.rr;
               ~~~~~~~~~~~~~~~~~~~~~
<stdin>:7:18: error: Cannot convert from type \"vec4\" to type \"int\"
  int v234ssst = v2.ssst + v2.ssst + v4.ssst;
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:9:18: error: Invalid swizzle \"xyz\" on type \"vec2\"
  int v2xyz = v2.xyz + v2.zyx;
                 ~~~
<stdin>:9:27: error: Invalid swizzle \"zyx\" on type \"vec2\"
  int v2xyz = v2.xyz + v2.zyx;
                          ~~~
<stdin>:10:19: error: Invalid swizzle \"xyzw\" on type \"vec3\"
  int v3xyzw = v3.xyzw + v3.wzyx;
                  ~~~~
<stdin>:10:29: error: Invalid swizzle \"wzyx\" on type \"vec3\"
  int v3xyzw = v3.xyzw + v3.wzyx;
                            ~~~~
<stdin>:12:7: error: The field \"r\" cannot be specified multiple times when used as a storage location
  v2.rr = v3.rr;
      ^
<stdin>:13:8: error: The field \"s\" cannot be specified multiple times when used as a storage location
  v3.sts = v4.sts;
       ^
<stdin>:14:7: error: The field \"x\" cannot be specified multiple times when used as a storage location
  v4.xx = v2.xx;
      ^
")

# Swizzles larger than four values are not allowed
test("
void main(vec2 v2, vec3 v3, vec4 v4) {
  v2.xyxyx;
  v3.xyzxy;
  v4.xyzwx;
}
", "
<stdin>:2:6: error: Invalid swizzle \"xyxyx\" on type \"vec2\"
  v2.xyxyx;
     ~~~~~
<stdin>:3:6: error: Invalid swizzle \"xyzxy\" on type \"vec3\"
  v3.xyzxy;
     ~~~~~
<stdin>:4:6: error: Invalid swizzle \"xyzwx\" on type \"vec4\"
  v4.xyzwx;
     ~~~~~
")

# Scalar swizzles are not allowed
test("
void main(bool b, int i, float f) {
  b.x;
  i.r;
  f.s;
}
", "
<stdin>:2:5: error: Cannot find \"x\" on type \"bool\"
  b.x;
    ^
<stdin>:3:5: error: Cannot find \"r\" on type \"int\"
  i.r;
    ^
<stdin>:4:5: error: Cannot find \"s\" on type \"float\"
  f.s;
    ^
")

# Scalar swizzles with values from different sets are not allowed
test("
void main(vec2 v2, vec3 v3, vec4 v4) {
  v2.xs;
  v3.xs;
  v4.xs;
}
", "
<stdin>:2:6: error: Invalid swizzle \"xs\" on type \"vec2\"
  v2.xs;
     ~~
<stdin>:3:6: error: Invalid swizzle \"xs\" on type \"vec3\"
  v3.xs;
     ~~
<stdin>:4:6: error: Invalid swizzle \"xs\" on type \"vec4\"
  v4.xs;
     ~~
")

# Test overloading error messages
test("
void foo(vec2 x);
void foo(ivec3 x);

void main() {
  foo(1, 2);
  foo(ivec2(1, 2));
}
", "
<stdin>:5:3: error: No matching overload for function \"foo\"
  foo(1, 2);
  ~~~
<stdin>:6:7: error: Cannot convert from type \"ivec2\" to type \"vec2\"
  foo(ivec2(1, 2));
      ~~~~~~~~~~~
")

# Check jumps and loops
test("
void main() {
  break;
  continue;

  for (int i = 0; i < 10; i++) break;
  for (int i = 0; i < 10; i++) continue;

  while (true) break;
  while (true) continue;

  do break; while(true);
  do continue; while(true);
}
", "
<stdin>:2:3: error: This statement cannot be used outside a loop
  break;
  ~~~~~
<stdin>:3:3: error: This statement cannot be used outside a loop
  continue;
  ~~~~~~~~
")

# Test control flow checking with if statements
test("
int bad1() {}

int bad2() {
  if (true) ;
  else return 0;
}

int bad3() {
  if (true) {}
  else discard;
}

int bad4(bool x, bool y) {
  if (x) return 0;
  else if (y) return 1;
  else ;
}

int bad5(bool x, bool y) {
  if (x) { return 0; }
  else if (y) { return 1; }
  else {}
}

int bad6(bool x) {
  if (x) 0;
  else 1;
}

int bad7(bool x) {
  if (x) { 0; }
  else { 1; }
}

int good1() {
  return 0;
}

int good2() {
  discard;
}

int good3() {
  if (true) return 0;
}

int good4() {
  if (true) discard;
}

int good5() {
  if (false) ;
  else return 0;
}

int good6() {
  if (false) {}
  else discard;
}

int good7(bool x, bool y) {
  if (x) return 0;
  else if (y) discard;
  else return 2;
}
", "
<stdin>:1:5: error: All control paths for \"bad1\" must return a value of type \"int\"
int bad1() {}
    ~~~~
<stdin>:3:5: error: All control paths for \"bad2\" must return a value of type \"int\"
int bad2() {
    ~~~~
<stdin>:8:5: error: All control paths for \"bad3\" must return a value of type \"int\"
int bad3() {
    ~~~~
<stdin>:13:5: error: All control paths for \"bad4\" must return a value of type \"int\"
int bad4(bool x, bool y) {
    ~~~~
<stdin>:19:5: error: All control paths for \"bad5\" must return a value of type \"int\"
int bad5(bool x, bool y) {
    ~~~~
<stdin>:25:5: error: All control paths for \"bad6\" must return a value of type \"int\"
int bad6(bool x) {
    ~~~~
<stdin>:30:5: error: All control paths for \"bad7\" must return a value of type \"int\"
int bad7(bool x) {
    ~~~~
")

# Test control flow checking with loops
test("
int badWhile1() {
  while (false) return 0;
}

int badWhile2() {
  while (false) { return 0; }
}

int badWhile3(bool x) {
  while (x) return 0;
}

int badWhile4(bool x) {
  while (x) { return 0; }
}

int badWhile5() {
  while (true) break;
}

int badWhile6() {
  while (true) { break; }
}

int goodWhile1() {
  while (true) ;
}

int goodWhile2() {
  while (true) {}
}

int goodDoWhile1() {
  do ; while (true);
}

int goodDoWhile2() {
  do {} while (true);
}

int goodFor1() {
  for (; true;) ;
}

int goodFor2() {
  for (; true;) {}
}

int goodFor3() {
  for (;;) ;
}

int goodFor4() {
  for (;;) {}
}
", "
<stdin>:1:5: error: All control paths for \"badWhile1\" must return a value of type \"int\"
int badWhile1() {
    ~~~~~~~~~
<stdin>:5:5: error: All control paths for \"badWhile2\" must return a value of type \"int\"
int badWhile2() {
    ~~~~~~~~~
<stdin>:9:5: error: All control paths for \"badWhile3\" must return a value of type \"int\"
int badWhile3(bool x) {
    ~~~~~~~~~
<stdin>:13:5: error: All control paths for \"badWhile4\" must return a value of type \"int\"
int badWhile4(bool x) {
    ~~~~~~~~~
<stdin>:17:5: error: All control paths for \"badWhile5\" must return a value of type \"int\"
int badWhile5() {
    ~~~~~~~~~
<stdin>:21:5: error: All control paths for \"badWhile6\" must return a value of type \"int\"
int badWhile6() {
    ~~~~~~~~~
")

# Test the not operator
test("
void main() {
  int x = !true;
  int y = !bvec2(true);
  int z = not(bvec2(true));
}
", "
<stdin>:2:11: error: Cannot convert from type \"bool\" to type \"int\"
  int x = !true;
          ~~~~~
<stdin>:3:11: error: No unary operator \"!\" for type \"bvec2\"
  int y = !bvec2(true);
          ^
<stdin>:4:11: error: Cannot convert from type \"bvec2\" to type \"int\"
  int z = not(bvec2(true));
          ~~~~~~~~~~~~~~~~
")

# Test comparison operators
test("
void main() {
  1 < 2;
  1.0 < 2.0;
  ivec2(1) < ivec2(2);
  mat2(1.0) < mat2(2.0);
  int vlt = lessThan(ivec2(1), ivec2(2));
  int mlt = lessThan(mat2(1.0), mat2(2.0));

  1 > 2;
  1.0 > 2.0;
  ivec2(1) > ivec2(2);
  mat2(1.0) > mat2(2.0);
  int vgt = greaterThan(ivec2(1), ivec2(2));
  int mgt = greaterThan(mat2(1.0), mat2(2.0));

  1 <= 2;
  1.0 <= 2.0;
  ivec2(1) <= ivec2(2);
  mat2(1.0) <= mat2(2.0);
  int vlte = lessThanEqual(ivec2(1), ivec2(2));
  int mlte = lessThanEqual(mat2(1.0), mat2(2.0));

  1 >= 2;
  1.0 >= 2.0;
  ivec2(1) >= ivec2(2);
  mat2(1.0) >= mat2(2.0);
  int vgte = greaterThanEqual(ivec2(1), ivec2(2));
  int mgte = greaterThanEqual(mat2(1.0), mat2(2.0));
}
", "
<stdin>:4:12: error: There is no operator \"<\" defined for type \"ivec2\"
  ivec2(1) < ivec2(2);
           ^
<stdin>:5:13: error: There is no operator \"<\" defined for type \"mat2\"
  mat2(1.0) < mat2(2.0);
            ^
<stdin>:6:13: error: Cannot convert from type \"bvec2\" to type \"int\"
  int vlt = lessThan(ivec2(1), ivec2(2));
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:7:13: error: No matching overload for function \"lessThan\"
  int mlt = lessThan(mat2(1.0), mat2(2.0));
            ~~~~~~~~
<stdin>:11:12: error: There is no operator \">\" defined for type \"ivec2\"
  ivec2(1) > ivec2(2);
           ^
<stdin>:12:13: error: There is no operator \">\" defined for type \"mat2\"
  mat2(1.0) > mat2(2.0);
            ^
<stdin>:13:13: error: Cannot convert from type \"bvec2\" to type \"int\"
  int vgt = greaterThan(ivec2(1), ivec2(2));
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:14:13: error: No matching overload for function \"greaterThan\"
  int mgt = greaterThan(mat2(1.0), mat2(2.0));
            ~~~~~~~~~~~
<stdin>:18:12: error: There is no operator \"<=\" defined for type \"ivec2\"
  ivec2(1) <= ivec2(2);
           ~~
<stdin>:19:13: error: There is no operator \"<=\" defined for type \"mat2\"
  mat2(1.0) <= mat2(2.0);
            ~~
<stdin>:20:14: error: Cannot convert from type \"bvec2\" to type \"int\"
  int vlte = lessThanEqual(ivec2(1), ivec2(2));
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:21:14: error: No matching overload for function \"lessThanEqual\"
  int mlte = lessThanEqual(mat2(1.0), mat2(2.0));
             ~~~~~~~~~~~~~
<stdin>:25:12: error: There is no operator \">=\" defined for type \"ivec2\"
  ivec2(1) >= ivec2(2);
           ~~
<stdin>:26:13: error: There is no operator \">=\" defined for type \"mat2\"
  mat2(1.0) >= mat2(2.0);
            ~~
<stdin>:27:14: error: Cannot convert from type \"bvec2\" to type \"int\"
  int vgte = greaterThanEqual(ivec2(1), ivec2(2));
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:28:14: error: No matching overload for function \"greaterThanEqual\"
  int mgte = greaterThanEqual(mat2(1.0), mat2(2.0));
             ~~~~~~~~~~~~~~~~
")

# Test the sequence operator
test("
void main() {
  int x = (0.5, 1 + 1.5, false);
}
", "
<stdin>:2:19: error: No binary operator \"+\" for type \"int\" and type \"float\"
  int x = (0.5, 1 + 1.5, false);
                  ^
<stdin>:2:11: error: Cannot convert from type \"bool\" to type \"int\"
  int x = (0.5, 1 + 1.5, false);
          ~~~~~~~~~~~~~~~~~~~~~
")

# Test the equality operator
test("
uniform sampler2D s2;
uniform samplerCube sC;

struct Foo1 {
  int x;
};

struct Foo2 {
  int x[2];
};

struct Foo3 {
  sampler2D x;
};

struct Foo4 {
  Foo1 x;
};

struct Foo5 {
  Foo3 x;
};

void main(int i, float f, bool b, vec2 v, mat2 m, int a[2], Foo1 F1, Foo2 F2, Foo3 F3, Foo4 F4, Foo5 F5) {
  0 == 0;
  0.0 == 0.0;
  false == false;
  vec2(0.0) == vec2(0.0);
  mat2(0.0) == mat2(0.0);

  i == 0;
  f == 0.0;
  b == false;
  v == vec2(0.0);
  m == mat2(0.0);

  i == i;
  f == f;
  b == b;
  v == v;
  m == m;
  a == a;
  s2 == s2;
  sC == sC;
  F1 == F1;
  F2 == F2;
  F3 == F3;
  F4 == F4;
  F5 == F5;
}
", "
<stdin>:42:5: error: There is no operator \"==\" defined for type \"int[2]\"
  a == a;
    ~~
<stdin>:43:6: error: There is no operator \"==\" defined for type \"sampler2D\"
  s2 == s2;
     ~~
<stdin>:44:6: error: There is no operator \"==\" defined for type \"samplerCube\"
  sC == sC;
     ~~
<stdin>:46:6: error: There is no operator \"==\" defined for type \"Foo2\"
  F2 == F2;
     ~~
<stdin>:47:6: error: There is no operator \"==\" defined for type \"Foo3\"
  F3 == F3;
     ~~
<stdin>:49:6: error: There is no operator \"==\" defined for type \"Foo5\"
  F5 == F5;
     ~~
")

# Check struct constructors
test("
struct S1 {
  int i;
  float f;
};

struct S2 {
  bool b;
  S1 s1;
};

void main() {
  S2 a = S2(false, S1(0, 0.5));
  S2 b = S2(S1(0.5, 0), false);
  S2 c = S2(false);
  S2 d = S2(false, S1(0));
  S2 e = S2(false, S1(0, 0.5, 1));
}
", "
<stdin>:13:16: error: Cannot convert from type \"float\" to type \"int\"
  S2 b = S2(S1(0.5, 0), false);
               ~~~
<stdin>:13:21: error: Cannot convert from type \"int\" to type \"float\"
  S2 b = S2(S1(0.5, 0), false);
                    ^
<stdin>:13:13: error: Cannot convert from type \"S1\" to type \"bool\"
  S2 b = S2(S1(0.5, 0), false);
            ~~~~~~~~~~
<stdin>:13:25: error: Cannot convert from type \"bool\" to type \"S1\"
  S2 b = S2(S1(0.5, 0), false);
                        ~~~~~
<stdin>:14:12: error: Expected 2 arguments but found 1 argument when constructing type \"S2\"
  S2 c = S2(false);
           ~~~~~~~
<stdin>:6:8: note: The definition of struct \"S2\" is here
struct S2 {
       ~~
<stdin>:15:22: error: Expected 2 arguments but found 1 argument when constructing type \"S1\"
  S2 d = S2(false, S1(0));
                     ~~~
<stdin>:1:8: note: The definition of struct \"S1\" is here
struct S1 {
       ~~
<stdin>:16:22: error: Expected 2 arguments but found 3 arguments when constructing type \"S1\"
  S2 e = S2(false, S1(0, 0.5, 1));
                     ~~~~~~~~~~~
<stdin>:1:8: note: The definition of struct \"S1\" is here
struct S1 {
       ~~
")

# Check that forward-declared functions can be used
test("
void foo();

void foo() {
}

void bar();

void baz() {
}

void main() {
  foo();
  bar();
  baz();
}
", "
void foo();

void foo() {
}

void bar();

void baz() {
}

void main() {
  foo();
  bar();
  baz();
}
")

# Check for a crash when attempting to fold a non-constant conditional expression
test("
export void main(vec4 foo) {
  foo[foo.x < 1.0 ? 0 : 1];
}
", "
void main(vec4 foo) {
  foo[foo.x < 1.0 ? 0 : 1];
}
")

# Check for a crash when attempting to check a return type without a function
test("
return 0;
", "
<stdin>:1:1: error: This statement cannot be used outside a function
return 0;
~~~~~~~~~
")

  }
}
